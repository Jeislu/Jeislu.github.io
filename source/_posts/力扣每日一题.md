---
title: 力扣每日一题
date: 2020-12-11 20:24:58
top: 2
tags:
- 算法
---

## 前言

之前每日一题的markdown文件不知道哪去了，只能重新开始写，以后记得备份文件！

记录本人力扣每日一题的思路，如果日期后面有补字，则代表当天忘了做，后面补上的

<!-- more -->

本来想弄个目录的，但是 Typora 自动生成目录又会带上题目、思路和代码这样的小题目，而且单一个日期好像也没什么用，想了想还是算了，毕竟如果要自己手动维护一个目录很麻烦，而且如果真的想针对性的找什么内容，使用`Ctrl + f`就可以直接搜索了。

## 2020/12/4（补）

### 题目

[659. 分割数组为连续子序列](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)

给你一个按升序排序的整数数组 `num`（可能包含重复数字），请你将它们分割成一个或多个长度至少为 3 的子序列，其中每个子序列都由连续整数组成。

如果可以完成上述分割，则返回 `true` ；否则，返回 `false` 。



**示例 1：**

```
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5
```

**示例 2：**

```
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5
```

**示例 3：**

```
输入: [1,2,3,4,4,5]
输出: False
```

 

**提示：**

- `1 <= nums.length <= 10000`

### 思路

采用哈希表 + 优先队列，遍历数组，访问当前的数据n的时候，查看是否有以n-1结尾的队列，如果有，则把该n加到最短的队列后面，否则创建一个以n开头的队列。最后遍历所有队列，如果长度都大于等于3，则返回真，否则返回假。

上面这个解法，好是好，但是太费时间了，在提交里面有看到另外一个解法，思路如下：

- 使用三个变量存储长度分别为1,2，大于等于3的队列的个数
- 遍历数据，每一次将相同的数据拿出来，然后判断该数据能否连上上一个数据。
  - 如果不可以，判断当前队列长度是否全大于3，如果全大于3，则放弃前面所有队列，然后新建当前相同数据个数的长度为1的队列，否则抛弃返回 false
  - 如果可以，判断是否能分配到所有队列长度为1和2后面
    - 如果不够则返回 false
    - 如果够，则更新三个数据，计算更新完队列1和2剩下的个数，然后和队列3取最小的，设为m。接着队列2更新为队列1，队列3 = 队列2 + m，更新队列1为剩下的数
  - 最后判断队列1和2是否都为0，为0返回 true 否则返回false。

### 代码

哈希表 + 优先队列

```java
public boolean isPossible(int[] nums) {
    // 哈希表 + 优先队列，key表示以何数结尾，value存储不同队列的长度
    Map<Integer, PriorityQueue<Integer>> map = new HashMap<Integer, PriorityQueue<Integer>>();
    for (int x : nums) {
        // 如果不存在则创建一个新队列
        if (!map.containsKey(x)) {
            map.put(x, new PriorityQueue<Integer>());
        }
        // 如果存在以 x - 1结尾的数据，则拿出最小的（由优先队列保证），然后加+1，放到上面新创建的队列中
        if (map.containsKey(x - 1)) {
            int prevLength = map.get(x - 1).poll();
            // 拿出来后，以 x - 1结果的队列的长度为0，则删掉该队列
            if (map.get(x - 1).isEmpty()) {
                map.remove(x - 1);
            }
            // 长度加一放回去
            map.get(x).offer(prevLength + 1);
        } else {
            // 否则创建一个长度为1的数据
            map.get(x).offer(1);
        }
    }
    // 遍历所有队列如果长度都大于等于3，则返回 true，否则返回 false
    Set<Map.Entry<Integer, PriorityQueue<Integer>>> entrySet = map.entrySet();
    for (Map.Entry<Integer, PriorityQueue<Integer>> entry : entrySet) {
        PriorityQueue<Integer> queue = entry.getValue();
        if (queue.peek() < 3) {
            return false;
        }
    }
    return true;
}
```

较优算法

```java
public boolean isPossible(int[] nums) {
    int n = nums.length;
    // 长度分别为1,2,≥3的队列
    int dp1 = 0;
    int dp2 = 0;
    int dp3 = 0;
    // 存储当前下标
    int idx = 0;
    // 存储一开始的下标
    int start;

    while(idx < n){
        // 初始化为当前
        start = idx;
        // 存储一开始位置的数据
        int x = nums[idx];
        // 把所有相同的数据拿出来
        while(idx < n && nums[idx] == x){
            idx++;
        }
        // 计算出相同数字的个数
        int cnt = idx - start;

        // 判断是否可以拼接上上一个数据
        if(start > 0 && x != nums[start - 1] + 1){
            // 如果不可以，则要求不存在长度为1,2的队列
            if(dp1 + dp2 > 0){
                return false;
            }else{
                // 抛弃前面所有队列（因为接不上了）
                dp1 = cnt;
                dp2 = dp3 = 0;
            }
        }else{
            // 判断是否够长度1和2的队列拼接，如果不可以则返回 false，
            // 因为这个数拼接后仍还剩下长度为1,2的队列，则下一个数肯定拼接不上
            if(dp1 + dp2 > cnt){
                return false;
            }
            // 计算拼接完剩下的数据
            int left = cnt - dp1 - dp2;
            // 计算出剩下的和长度大于等于3的队列中较小的
            int keep = Math.min(dp3,left);
            // 最后，我们更新 dp1,dp2,dp3的取值
            dp3 = keep + dp2;
            dp2 = dp1;
            dp1 = left - keep;
        }
    }
    
    return dp1 == 0 && dp2 == 0;
}
```

## 20202/12/9（补）

### 题目

[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

难度中等843收藏分享切换为英文接收动态反馈

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

### 思路

DP，初始化两边，然后更新到终点。

组合排列，高中知识

### 代码

DP

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        // 初始化边界
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        // 初始化边界
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        // DP更新数据
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        
        return f[m - 1][n - 1];
    }
}
```

组合

```java
public int uniquePaths(int m, int n) {
    // 需要走的总步数
    int steps = m + n - 2;
    // 从横步数或者纵步数里面选择最小的，答案是一样的，只是减少计算
    int minCount = Math.min(m,n)-1;
    // 计算总的路线，使用long防止溢出
    long mole = 1;
    // 重复的
    long deno = 1;
    while(minCount != 0){
        mole *= steps;
        steps--;
        deno *= minCount;
        minCount--;
    }
    return (int)(mole/deno);
}
```

组合简单写法（题解写法）

```java
class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
}
```



## 2020/12/11

### 题目

[649. Dota2 参议院](https://leetcode-cn.com/problems/dota2-senate/)

Dota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的`**一**`项：

1. `禁止一名参议员的权利`：

   参议员可以让另一位参议员在这一轮和随后的几轮中丧失**所有的权利**。

2. `宣布胜利`：

​     如果参议员发现有权利投票的参议员都是**同一个阵营的**，他可以宣布胜利并决定在游戏中的有关变化。

 

给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。

 

**示例 1：**

```
输入："RD"
输出："Radiant"
解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
```

**示例 2：**

```
输入："RDD"
输出："Dire"
解释：
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

 

**提示：**

- 给定字符串的长度在 `[1, 10,000]` 之间.

### 思路

贪心算法解决，每一个有票的人，只需要干掉离自己最近的对方阵营的人即可，当一个阵营没人，留下来的就是胜利的！

### 代码

```java
public String predictPartyVictory(String senate){
    int len  = senate.length();
    boolean[] used = new boolean[len];
    int RLen=0,DLen=0,RNum=0,DNum=0;

    // 更新人数
    for(int i = 0; i < len; i++){
        if(senate.charAt(i) == 'D'){
            DNum++;
        }else{
            RNum++;
        }
    }

    while(RNum > 0 && DNum > 0){
        for(int i = 0; i < len && RNum > 0 && DNum > 0; i++){
            if(!used[i]){
                if(senate.charAt(i) == 'R'){
                    if(DLen > 0){
                        DLen--;
                        used[i] = true;
                        RNum--;
                    }else{
                        RLen++;
                    }
                }else{
                    if(RLen > 0){
                        RLen--;
                        used[i] = true;
                        DNum--;
                    }else{
                        DLen++;
                    }
                }
            }
        }
    }

    return DNum > 0 ? "Dire" : "Radiant";
}
```

## 2020/12/12

### 题目

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 O(*n*) 时间复杂度完成此题?

### 思路

采用DP，从头到尾递推即可。

使用两个变量，hLen表示升序序列长度，lLen表示降序序列长度，都初始化为1

如果当前的数据比前一个数据大，则更新hLen，hLen = max(lLen + 1 , hLen)，如果比前一个数据小，则更新lLen，lLen = max(hLen + 1, lLen)。

为什么可以用前一个数据代替摆动数列的尾部呢？因为如果这一次比较无法更新数据，则用当前数据顶替尾部数据，例如当前摆动数列的尾部为7（上升），升序长度为10，当前数据为9，更新降序长度后，因为升序的下一个只能找降序，所以用10顶替7没有问题。

### 代码

```java
public int wiggleMaxLength(int[] nums){
    int len = nums.length;
    if(len < 2){
        return len;
    }

    int hLen = 1;          // 存储升序的长度
    int lLen = 1;          // 存储降序的长度

    for(int i = 1; i < len; i++){
        if(nums[i] > nums[i-1]){
            hLen = Math.max(lLen+1,hLen);
        }else if(nums[i] < nums[i-1]){
            lLen = Math.max(hLen+1,lLen);
        }
    }

    return Math.max(hLen,lLen);
}
```

## 2020/12/13

### 题目

[217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

 

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```

### 思路

暴力的就排序，然后遍历数组，比较前后两个数字是否相同。

优化一点就使用HashSet来存储数据，然后根据HashSet的size()和数组长度进行比较，如果一致，则无重复。这个还可以进一步剪枝，因为Set的add()方法根据添加成功与否会返回一个boolean值，如果出现一次添加失败，则可以判断有重复数据

### 代码

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> data = new HashSet<>();
    for(int i = 0; i < nums.length; i++){
        if(!data.add(nums[i])){
            return true;
        }
    }

    return false;
}
```

## 2020/12/14

### 题目

[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

### 思路

解法一（我的解法）给每一个字符串一个Hash值，Hash值的有如下规则

- 不同长度的字符串Hash值一定不等
- 相同长度，组成字母一样的字符串Hash值相等

具体实现看代码，不过这是很取巧的方式，因为一旦字符串的长度很长，位数的设置值太大，使得int超出范围(不过采取long类型可以避免)，由于字符的值最大才25（字符 - 'a'），所以才能平方那么多次，不过代价就是运行慢，主要时间都花费在计算Hash值（也可以采取其他计算方法，例如映射成质数，然后把映射的值相乘取mod，由于Hash的计算方法简单，而且没有其他处理，所以肯定存在某个数Hash相同而构成不同）



解法二：

将每一个字符串转化成char[]，这样就可以对数组进行排序，排序完再转化成String，然后通过HashMap来存储，相同构成字符串在排序后是一样的，这种就比我的快多了

### 代码

解法一

```java
 public List<List<String>> groupAnagrams(String[] strs) {
     int len = strs.length;
     List<List<String>> ans = new LinkedList<>();
     if(len == 0){
         return ans;
     }

     Integer[] data = new Integer[len];
     Integer[] index = new Integer[len];
     for(int i = 0; i < len; i++){
         data[i] = getNum(strs[i]);
         index[i] = i;
     }

     Arrays.sort(index, new Comparator<Integer>() {
         @Override
         public int compare(Integer o1, Integer o2) {
             return data[o1] - data[o2];
         }
     });

     List<String> tempList = new LinkedList<>();
     tempList.add(strs[index[0]]);
     ans.add(tempList);

     for(int i = 1; i < len; i++){
         if(data[index[i]].equals(data[index[i-1]])){
             tempList.add(strs[index[i]]);
         }else{
             tempList = new LinkedList<>();
             tempList.add(strs[index[i]]);
             ans.add(tempList);
         }
     }
     return ans;
 }

public int getNum(String data){
    int len = data.length();
    int ans = 0;
    for(int i = 0; i < len; i++){
        ans += Math.pow((data.charAt(i) - 'a') + 1,5);
    }
    ans += (len * 100000000);
    return ans;
}
```

解法二

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<String, List<String>>();
    for (String str : strs) {
        char[] array = str.toCharArray();
        Arrays.sort(array);
        String key = new String(array);
        List<String> list = map.getOrDefault(key, new ArrayList<String>());
        list.add(str);
        map.put(key, list);
    }
    return new ArrayList<List<String>>(map.values());
}
```

## 2020/12/15

### 题目

[738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）

**示例 1:**

```
输入: N = 10
输出: 9
```

**示例 2:**

```
输入: N = 1234
输出: 1234
```

**示例 3:**

```
输入: N = 332
输出: 299
```

**说明:** `N` 是在 `[0, 10^9]` 范围内的一个整数。

### 思路

解法一：

转换成从头到尾找第一个出现不协调的地方，即前面比后面大，然后再往前找和这个数相同的位，更新不协调位，因为当前位-1后，如果上一个数和当前数相同，会出现新的不协调，把不协调位的值-1，然后把它后面的位都置9

解法二：

从尾到头取数据，如果当前位比前一位大，则当前位乘以权值-1（相当于当前位-1，后面所有位指9）替换目标值，否则就把当前位乘以权值加到目标值，重复这个过程，直到遍历完。

这个写的实在是太漂亮了，虽然我一开始也想了直接用Int来解决，但是觉得实现起来可能和解法一没什么区别，就是优化一点点，但是这个就写的太漂亮了。

### 代码

解法一：

```java
public int monotoneIncreasingDigits(int N) {
    if(N < 10){
        return N;
    }

    char[] data = String.valueOf(N).toCharArray();
    int len = data.length;
    // 找到第一个出现不协调的地方
    for(int i = 0; i < len - 1; i++){
        if (data[i] > data[i+1]){
            // 往前搜索和他相同的数字
            int temp = data[i];
            for(int j = i - 1; j >= 0; j--){
                if(temp == data[j]){
                    i--;
                }
            }
            data[i] = (char)(data[i] - 1);
            for(int j = i + 1; j < len; j++){
                data[j] = '9';
            }
            break;
        }
    }

    return Integer.valueOf(String.valueOf(data));
}
```

解法二：

```java
public int monotoneIncreasingDigits(int N) {
    int rs = 0, exp = 1, p = 10;
    while (N > 0) {
        int t = N % 10;
        if (t <= p) {
            rs += t * exp;
            p = t;
        }
        else {
            rs = t * exp - 1;
            p = t - 1;
        }
        N /= 10;
        exp *= 10;
    }
    return rs;
}
```

## 2020/12/16

### 题目

[290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
```

**示例 4:**

```
输入: pattern = "abba", str = "dog dog dog dog"
输出: false
```

**说明:**
你可以假设 `pattern` 只包含小写字母， `str` 包含了由单个空格分隔的小写字母。  

### 思路

使用两个Map进行双向绑定，单向绑定会出问题

### 代码

```java
public boolean wordPattern(String pattern, String s) {
    int len1 = pattern.length();
    String[] str = s.split(" ");
    int len2 = str.length;

    if(len1 != len2){
        return false;
    }

    if(len1 == 0){
        return true;
    }



    HashMap<String,Character> data = new HashMap<>();
    HashMap<Character,String> data2 = new HashMap<>();
    for(int i = 0; i < len1; i++){
        char tempData = data.getOrDefault(str[i],' ');
        String tempData2 = data2.getOrDefault(pattern.charAt(i)," ");
        if(' ' == tempData && " ".equals(tempData2)){
            data.put(str[i],pattern.charAt(i));
            data2.put(pattern.charAt(i),str[i]);
            continue;
        }

        if(tempData != pattern.charAt(i)){
            return false;
        }
    }

    return true;
}
```



## 2020/12/17

### 题目

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**注意:**

- `0 < prices.length <= 50000`.
- `0 < prices[i] < 50000`.
- `0 <= fee < 50000`.

### 思路

使用dp来维护每个下标的状态：

- 状态0 ：当前没有股票，可以从持有股票通过卖掉股票转换来，或者从没有股票转换来。
- 状态1 ：当前有股票，可以由继续持有股票转换来，或者当前节点买入股票。

观察发现并不需要一整个数组的dp，每一次更新只用到了上一个节点，所以使用两个变量即可

下面附上没有优化和优化过的代码

### 代码

```java
// 未优化
public int maxProfit(int[] prices, int fee) {
    int len = prices.length;

    // 0存储当前未持有，1表示当前已持有
    int[][] dp = new int[len][2];
    // 初始化第一个节点
    dp[0][0] = 0;
    dp[0][1] = -prices[0]-fee;

    for(int i = 1; i < len; i++){
        // 当前未持有可能是本来就没有或者之前有，现在刚好卖了
        dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);

        // 当前持有可能是本来没有现在刚买，或者是继续持有
        dp[i][1] = Math.max(dp[i-1][0] - prices[i] - fee, dp[i-1][1]);
    }

    return Math.max(dp[len-1][0],dp[len-1][1]);
}
```

```java
// 优化
public int maxProfit(int[] prices, int fee) {
        int len = prices.length;
        // 初始化第一个节点
        int have = -prices[0]-fee;
        int nHave = 0;

        for(int i = 1; i < len; i++){
            // 当前未持有可能是本来就没有或者之前有，现在刚好卖了
            nHave = Math.max(nHave,have + prices[i]);

            // 当前持有可能是本来没有现在刚买，或者是继续持有
            have = Math.max(nHave - prices[i] - fee, have);
        }

        return Math.max(have,nHave);
    }
```

## 2020/12/18

### 题目

[389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。

字符串 ***t\*** 由字符串 ***s\*** 随机重排，然后在随机位置添加一个字母。

请找出在 ***t*** 中被添加的字母。

 

**示例 1：**

```
输入：s = "abcd", t = "abcde"
输出："e"
解释：'e' 是那个被添加的字母。
```

**示例 2：**

```
输入：s = "", t = "y"
输出："y"
```

**示例 3：**

```
输入：s = "a", t = "aa"
输出："a"
```

**示例 4：**

```
输入：s = "ae", t = "aea"
输出："a"
```

 

**提示：**

- `0 <= s.length <= 1000`
- `t.length == s.length + 1`
- `s` 和 `t` 只包含小写字母

### 思路

计数即可

### 代码

```java
public char findTheDifference(String s, String t) {
    int[] dataS = new int[26];
    int lenS = s.length();

    for(int i = 0; i < lenS; i++){
        dataS[s.charAt(i) - 'a']++;
        dataS[t.charAt(i) - 'a']--;
    }
    dataS[t.charAt(lenS) - 'a']--;

    for(int i = 0; i < 26; i++){
        if (dataS[i] < 0){
            return (char)('a' + i);
        }
    }
    // 此返回作为数据出错的判断
    return '0';
}
```

## 2020/12/19

### 题目

[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**[原地](https://baike.baidu.com/item/原地算法)**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

### 思路

递归+模拟反转，每一次拿最外面的一圈进行交换，然后递归交换里面一圈

### 代码

```java
// 也可以作为参数传递，这里外提了
int len;

public void rotate(int[][] matrix) {
    len = matrix.length;
    solve(matrix,0);
}

public void solve(int[][] matrix, int count){
    if (len - (count + 1) * 2 < 0){
        return;
    }
    int[] tempData = new int[len - 2 * count];

    // 备份第一行的数据
    for(int i = count; i < len - count; i++){
        tempData[i - count] = matrix[count][i];
    }


    for(int i = count; i < len - count - 1; i++){
        // 第一竖放到第一行
        matrix[count][i] = matrix[len-count-1-(i-count)][count];
    }

    for(int i = count; i < len - count - 1; i++){
        // 最后一行放到第一竖
        matrix[len-count-1-(i-count)][count] = matrix[len-count-1][len - count - 1 - (i-count)];
    }

    for(int i = count; i < len - count - 1; i++){
        // 最后一竖放到最后一行
        matrix[len-count-1][i] = matrix[len-count-1-(i-count)][len-count-1];
    }

    for(int i = count; i < len - count; i++){
        // 最后一竖放上提前存储的第一行的数据
        matrix[i][len-count-1] = tempData[i-count];
    }

    solve(matrix,count+1);
}
```

## 2020/12/20

### 题目

[316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

**注意：**该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同

 

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb"
```

 

**提示：**

- `1 <= s.length <= 104`
- `s` 由小写英文字母组成

### 思路

构建一个栈（双向队列）维护数据。遍历数据，如果当前数据未使用且比栈顶元素小，并且栈顶元素数量多于1，则弹出栈顶元素，重复这个过程直到栈顶元素小于当前元素或者栈为空

### 代码

```java
public String removeDuplicateLetters(String s) {
    int len = s.length();
    // 存储字符数量
    int[] data = new int[26];
    // 是否存储
    boolean[] used = new boolean[26];
    char[] str = s.toCharArray();
    // 统计数据
    for(int i = 0; i < len; i++){
        data[str[i] - 'a']++;
    }
    // 比较栈
    Stack<Character> stack = new Stack<>();

    for(int i = 0; i < len; i++){
        // 未保存
        if(!used[str[i] - 'a']){
            while(!stack.empty() && stack.peek() > str[i]){
                // 栈顶字符的数量不止一个
                if(data[stack.peek() - 'a'] > 0){
                    used[stack.pop() - 'a'] = false;
                }else{
                    break;
                }
            }
            stack.push(str[i]);
            used[str[i] - 'a'] = true;
        }
        // 数量减一
        data[str[i] - 'a']--;
    }

    StringBuffer ans = new StringBuffer();
    while(!stack.isEmpty()){
        ans.append(stack.pop());
    }

    return ans.reverse().toString();
}
```

## 2020/12/21

### 题目

[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

数组的每个索引作为一个阶梯，第 `i`个阶梯对应着一个非负数的体力花费值 `cost[i]`(索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

**示例 1:**

```
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
```

 **示例 2:**

```
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

**注意：**

1. `cost` 的长度将会在 `[2, 1000]`。
2. 每一个 `cost[i]` 将会是一个Integer类型，范围为 `[0, 999]`。

### 思路

正常dp题，每一个楼梯的累加费用通过前两个楼梯即可求出，返回倒数第二个或者最后一个中费用最小的即可。

### 代码

```java
public int minCostClimbingStairs(int[] cost) {
    int len = cost.length;
    // 初始化
    int fast = cost[0];
    int second = cost[1];
    // 保存临时值
    int temp;
    for(int i = 2; i < len; i++){
        temp = second;
        second = Math.min(fast,second) + cost[i];
        fast = temp;
    }

    return Math.min(fast,second);
}
```

## 2020/12/22

### 题目

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回锯齿形层序遍历如下：

```
[
  [3],
  [20,9],
  [15,7]
]
```

### 思路

使用一个信号，来确定当前是从头到尾拿数据还是从尾到头拿数据，数据结构选择双向队列。

### 代码

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> ans = new LinkedList<>();
    // 树空返回
    if(root == null){
        return ans;
    }
    Deque<TreeNode> q = new LinkedList<>();
    q.add(root);
    // 控制从左到右还是从右到左
    boolean flag = true;
    while(!q.isEmpty()){
        // 获取当前层的结点数
        int size = q.size();
        List<Integer> tempList = new LinkedList<>();
        while(size != 0){
            size--;
            TreeNode tempNode;
            // 每一层改变一次方向
            if(flag){
                tempNode = q.pollFirst();
                // 从头开始拿就从左子树开始加
                if(tempNode.left != null){
                    q.addLast(tempNode.left);
                }
                if(tempNode.right != null){
                    q.addLast(tempNode.right);
                }
            }else{
                tempNode = q.pollLast();
                // 从尾开始拿就从右子树开始加
                if(tempNode.right != null){
                    q.addFirst(tempNode.right);
                }
                if(tempNode.left != null){
                    q.addFirst(tempNode.left);
                }
            }
            tempList.add(tempNode.val);
        }
        flag = !flag;
        ans.add(tempList);
    }
    return ans;
}
```

## 2020/12/23

### 题目

[387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**示例：**

```
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
```

 

**提示：**你可以假定该字符串只包含小写字母。

### 思路

从头到尾遍历数组，如果当前字符没有查询过，则从尾到头查询相同字符，查询结果如果和当前字符的下标相同，则表示只有一个，返回下标，如果遍历结束没有返回，则表示没有单一字符，返回-1

### 代码

```java
public int firstUniqChar(String s) {
    int len = s.length();
    // 判断某个字符是否使用过
    boolean[] used = new boolean[26];

    for(int i = 0; i < len; i++){
        char tempData = s.charAt(i);
        // 此字符前面已经有一样的数据
        if(used[tempData - 'a']){
            continue;
        }
        int temp = s.lastIndexOf(tempData);
        // 从后面找第一个相同字符也是同样下标即证明唯一
        if(temp == i){
            return i;
        }
        // 标记此字符已判别过
        used[tempData-'a'] = true;
    }

    return -1;
}
```

## 2020/12/24

### 题目

[135. 分发糖果](https://leetcode-cn.com/problems/candy/)

老师想给孩子们分发糖果，有 *N* 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

- 每个孩子至少分配到 1 个糖果。
- 相邻的孩子中，评分高的孩子必须获得更多的糖果。

那么这样下来，老师至少需要准备多少颗糖果呢？

**示例 1:**

```
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
```

**示例 2:**

```
输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

### 思路

从左到右遍历数据，如果当前数据的等级比前一个高，则当前分为糖果为前一个数据的糖果数+1，更新当前数据后，从这个位置向前更新数据，因为当前位置的更新，可能导致之前数据分配不对。

此方法可以进行优化，没必要每一次分配糖果都更新前面的数据，可以等遍历完，再完整的进行一次更新即可

### 代码

未优化

```java
public int candy(int[] ratings) {
    int len = ratings.length;
    if(len < 2){
        return len;
    }
    // 由于默认需要1颗糖，大家都有就是大家都没有，最后值加上长度即可
    int[] data = new int[len];
    int sum = 0;

    // 初始化第一个和最后一个
    if(ratings[0] > ratings[1]){
        data[0] = 1;
    }
    /*
            遍历数组，如果遇到level比左边高的，更新为左边糖数+1，然后向左边更新数据
         */
    for(int i = 1; i < len; i++){
        if(ratings[i] > ratings[i-1]){
            data[i] = data[i-1] + 1;
            int tempI = i-1;
            while(tempI >= 0){
                // 在一直更新的基础上，右边默认是符合规则的
                if(ratings[tempI] > ratings[tempI+1] && data[tempI] <= data[tempI+1]){
                    data[tempI] = data[tempI+1]+1;
                    tempI--;
                }else{
                    // 如果当前符合，那么前面的也是符合的
                    break;
                }
            }
        }else if(ratings[i] == ratings[i-1]){
            data[i] = 0;
        }else{
            int tempI = i-1;
            while(tempI >= 0){
                // 在一直更新的基础上，右边默认是符合规则的
                if(ratings[tempI] > ratings[tempI+1] && data[tempI] <= data[tempI+1]){
                    data[tempI] = data[tempI+1]+1;
                    tempI--;
                }else{
                    // 如果当前符合，那么前面的也是符合的
                    break;
                }
            }
        }
    }

    sum = Arrays.stream(data).sum();
    sum += len;

    return sum;
}
```

优化

```java
public int candy(int[] ratings) {
    int len = ratings.length;
    if(len < 2){
        return len;
    }
    // 由于默认需要1颗糖，大家都有就是大家都没有，最后值加上长度即可
    int[] data = new int[len];
    int sum = 0;

    // 初始化第一个和最后一个
    if(ratings[0] > ratings[1]){
        data[0] = 1;
    }

    // 从头到尾遍历数组，如果遇到level比左边高的，更新为左边数+1
    for(int i = 1; i < len; i++){
        if(ratings[i] > ratings[i-1]){
            data[i] = data[i-1] + 1;
        }
    }

    // 从尾到头遍历数组，如果遇到level比右边高的，更新为右边数+1
    for(int i = len - 2; i >= 0; i--){
        if (ratings[i] > ratings[i+1] && data[i] <= data[i+1]){
            data[i] = data[i+1] + 1;
        }
    }
    sum = Arrays.stream(data).sum();
    sum += len;

    return sum;
}
```

## 2020/12/25

### 题目

[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```



**提示：**

- `1 <= g.length <= 3 * 104`
- `0 <= s.length <= 3 * 104`
- `1 <= g[i], s[j] <= 231 - 1`

### 思路

排序后贪心，将最大的饼干给当前队列胃口最大的孩子总不会有错

### 代码

```java
public int findContentChildren(int[] g, int[] s) {
    int len1 = g.length - 1;
    int len2 = s.length - 1;
    int ans = 0;
    // 先排序
    Arrays.sort(g);
    Arrays.sort(s);

    while(len1 >= 0 && len2 >= 0){
        if(s[len2] >= g[len1]){
            len1--;
            len2--;
            ans++;
        }else{
            len1--;
        }
    }

    return ans;
}
```

## 2020/12/26

### 题目

[85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

**示例 2：**

```
输入：matrix = []
输出：0
```

**示例 3：**

```
输入：matrix = [["0"]]
输出：0
```

**示例 4：**

```
输入：matrix = [["1"]]
输出：1
```

**示例 5：**

```
输入：matrix = [["0","0"]]
输出：0
```

 

**提示：**

- `rows == matrix.length`
- `cols == matrix[0].length`
- `0 <= row, cols <= 200`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

### 思路

我无思路，具体思路看题解

### 代码

```java
public int maximalRectangle(char[][] matrix) {
    int m = matrix.length;
    if (m == 0) {
        return 0;
    }
    int n = matrix[0].length;
    int[][] left = new int[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] == '1') {
                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;
            }
        }
    }

    int ret = 0;
    for (int j = 0; j < n; j++) { // 对于每一列，使用基于柱状图的方法
        int[] up = new int[m];
        int[] down = new int[m];

        Deque<Integer> stack = new LinkedList<Integer>();
        for (int i = 0; i < m; i++) {
            while (!stack.isEmpty() && left[stack.peek()][j] >= left[i][j]) {
                stack.pop();
            }
            up[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }
        stack.clear();
        for (int i = m - 1; i >= 0; i--) {
            while (!stack.isEmpty() && left[stack.peek()][j] >= left[i][j]) {
                stack.pop();
            }
            down[i] = stack.isEmpty() ? m : stack.peek();
            stack.push(i);
        }

        for (int i = 0; i < m; i++) {
            int height = down[i] - up[i] - 1;
            int area = height * left[i][j];
            ret = Math.max(ret, area);
        }
    }
    return ret;
}
```

## 2020/12/27

### 题目

[205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

给定两个字符串 ***s*** 和 ***t\***，判断它们是否是同构的。

如果 ***s*** 中的字符可以被替换得到 ***t\*** ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例 1:**

```
输入: s = "egg", t = "add"
输出: true
```

**示例 2:**

```
输入: s = "foo", t = "bar"
输出: false
```

**示例 3:**

```
输入: s = "paper", t = "title"
输出: true
```

**说明:**
你可以假设 ***s*** 和 **t** 具有相同的长度。

### 思路

这道题其实就是问 s 和 t 的字符结构要匹配，给每个字符映射一个数字，然后根据这个数字来算出当前字符串的模式值(自己定义的一个概念，即由于每个字符都对应一个数字，所以可以根据这些数字算出一个可能是每个结构都唯一的值)，计算方法如代码所示，接着只需要比较这个模式值就可以了。

### 代码

```java
public boolean isIsomorphic(String s, String t) {
    // 题目说s和t长度相同，所以只需要算一个
    int len1 = s.length();

    // 存储 s 哪个数字已使用，以及不同的字符对应的数字
    int[] data1 = new int[129];
    // 存储 t 哪个数字已使用，以及不同的字符对应的数字
    int[] data2 = new int[129];
    
    // 对应模式的值
    int sumS = 0;
    int sumT = 0;

    // 存储当前已使用不同的字符数
    int count1 = 1;
    int count2 = 1;
    // 计算字符串 s 的模式值
    for(int i = 0; i < len1; i++){
        int temp1 = s.charAt(i);
        int temp2 = t.charAt(i);

        // s部分
        // 0代表此字符未使用
        if(data1[temp1] == 0){
            // 字符和数字对应
            data1[temp1] = count1;
            sumS = sumS * 10 + count1;
            count1++;
        }else{
            // 老字符则直接拿出来
            sumS = sumS * 10 + data1[temp1];
        }

        // t部分
        if(data2[temp2] == 0){
            data2[temp2] = count2;
            sumT = sumT * 10 + count2;
            count2++;
        }else{
            sumT = sumT * 10 + data2[temp2];
        }
    }

    return sumS == sumT;
}
```

## 2020/12/28

### 题目

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

**提示：**

- `0 <= k <= 109`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

### 思路

使用DP，就是再加一维数组来标记股票的购买数，具体看题解（我也是看题解的）

### 代码

```java
public int maxProfit(int k, int[] prices) {
    if (prices.length == 0) {
            return 0;
        }

        int n = prices.length;
        // 两者取最小，因为不一定会达到k次那么多，节约空间
        k = Math.min(k, n / 2);
        int[][] buy = new int[n][k + 1];
        int[][] sell = new int[n][k + 1];

        buy[0][0] = -prices[0];
        sell[0][0] = 0;
        // 初始化为特殊值，标记异常状态
        for (int i = 1; i <= k; ++i) {
            buy[0][i] = sell[0][i] = Integer.MIN_VALUE / 2;
        }

        for (int i = 1; i < n; ++i) {
            // 提前更新购买状态以用来推导后面更新，可以从上一天转化而来，也可以现在刚买入一支股票
            buy[i][0] = Math.max(buy[i - 1][0], sell[i - 1][0] - prices[i]);
            for (int j = 1; j <= k; ++j) {
                buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j] - prices[i]);
                sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);
            }
        }

        return Arrays.stream(sell[n - 1]).max().getAsInt();
}
```

## 2020/12/29

### 题目

[330. 按要求补齐数组](https://leetcode-cn.com/problems/patching-array/)

给定一个已排序的正整数数组 *nums，*和一个正整数 *n 。*从 `[1, n]` 区间内选取任意个数字补充到 *nums* 中，使得 `[1, n]` 区间内的任何数字都可以用 *nums* 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

**示例 1:**

```
输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
```

**示例 2:**

```
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
```

**示例 3:**

```
输入: nums = [1,2,2], n = 5
输出: 0
```

### 思路

对于正整数 xx，如果区间 [1,x−1] 内的所有数字都已经被覆盖，且 xx 在数组中，则区间 [1,2x-1] 内的所有数字也都被覆盖。证明如下。

> 对于任意 1 <= y < x，y 已经被覆盖，x 在数组中，因此 y+x 也被覆盖，区间 [x+1,2x-1]（即区间 [1,x−1] 内的每个数字加上 x 之后得到的区间）内的所有数字也被覆盖，由此可得区间 [1,2x−1] 内的所有数字都被覆盖。

使用贪心算法，每一次填充一个最小的缺少的值，假如填充的数为3，则2 * 3 - 1 = 5，这个范围的数就都填充完毕，证明如上。

### 代码

```java
public int minPatches(int[] nums, int n) {
        // 额外填充的数字个数
        int patches = 0;
        // 当前需要填充的数
        long x = 1;
        int length = nums.length;
        // 数组的使用下标
        int index = 0;
        while (x <= n) {
            // 第一个条件防止越界，第二个来判断是否可以填充
            if (index < length && nums[index] <= x) {
                x += nums[index];
                index++;
            } else {
                // 不能填充的话补上当前数，然后跳过2x - 1的数，也就是填充2x
                x *= 2;
                patches++;
            }
        }
        return patches;
    }
```

## 2020/12/30

### 题目

[1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

 

**示例：**

```
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
```

 

**提示：**

1. `1 <= stones.length <= 30`
2. `1 <= stones[i] <= 1000`

### 思路

使用一个优先队列维护，然后每一次从队首拿出两个元素，相减以后，如果不为0则加回队列，重复此步骤，直到队列的长度小于等于1

### 代码

```java
public int lastStoneWeight(int[] stones) {
    // 优先队列保证队首是最大值
    PriorityQueue<Integer> pq = new PriorityQueue<>((a1 , a2) -> a2 - a1);

    // 存储数据
    for(int data : stones){
        pq.add(data);
    }

    // 石头相碰
    while(pq.size() > 1){
        int s1 = pq.poll();
        int s2 = pq.poll();
        int temp = s1 - s2;
        if(temp != 0){
            pq.add(temp);
        }
    }
    // 如果里面没有元素了，则返回0，否则返回最后一个
    if(pq.size() == 0){
        return 0;
    }else{
        return pq.poll();
    }
}
```

## 2020/12/31

### 题目

[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

### 思路

贪心思想，按最早的结束位置对数组进行排序，然后遍历数组，如果当前数组可以拼接上上一个则留下，否则抛弃。

### 代码

```java
public int eraseOverlapIntervals(int[][] intervals) {
    int len = intervals.length;
    // 长度小于等于1，肯定不存在重叠
    if(len <= 1){
        return 0;
    }
    // 按结束从小到大排序
    Arrays.sort(intervals,((o1, o2) -> o1[1]==o2[1]?o1[0]-o2[0]:o1[1]-o2[1]));
    // 存储上一个结束的位置
    int ed = intervals[0][1];
    // 移出的个数
    int ans = 0;

    for(int i = 1; i < len; i++){
        // 开始的位置小于结束位置，则抛弃这个区间
        if(intervals[i][0] < ed){
            ans++;
        }else{
            ed = intervals[i][1];
        }
    }

    return ans;
}
```

## 2021/1/1

### 题目

[605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 **n** 。能否在不打破种植规则的情况下种入 **n** 朵花？能则返回True，不能则返回False。

**示例 1:**

```
输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
```

**示例 2:**

```
输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
```

**注意:**

1. 数组内已种好的花不会违反种植规则。
2. 输入的数组长度范围为 [1, 20000]。
3. **n** 是非负整数，且不会超过输入数组的大小。

### 思路

贪心思路，根据上一个判断当前是否能种花，能种直接种，但是有一些花是之前就存在的，所以如果遍历到已经存在的话，则看一下上一个是不是花，是的话直接拔了。

0 0 0 **1** -> 1 0 1 **1** -> 1 0 0 **1**

0 0 0 **1** -> 0 1 0 **1**

此贪心是最优的

### 代码

```java
public boolean canPlaceFlowers(int[] flowerbed, int n) {
    // 能栽种的花的最大数量
    int maxFlowers = 0;
    int len = flowerbed.length;
    // 保存上一个位置的是不是花
    boolean isFlower;
    if(flowerbed[0] == 0){
        maxFlowers++;
        isFlower = true;
    }else{
        isFlower = true;
    }

    for(int i = 1; i < len; i++){
        // 当前没有花，判断上一个是否是花
        if(flowerbed[i] == 0){
            // 上一个是花，则更新标识
            if(isFlower){
                isFlower = false;
            }else{
                // 上一个不是花，在当前种下花
                maxFlowers++;
                isFlower = true;
            }
        }else{
            // 当前是花，则判断上一个是不是花
            // 如果是花，拔掉上一朵花
            if(isFlower){
                maxFlowers--;
            }
            // 更新标识
            isFlower = true;
        }
    }

    return maxFlowers >= n;
}
```

## 2021/1/2

### 题目

[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**示例 3：**

```
输入：nums = [1,-1], k = 1
输出：[1,-1]
```

**示例 4：**

```
输入：nums = [9,11], k = 2
输出：[11]
```

**示例 5：**

```
输入：nums = [4,-2], k = 2
输出：[4]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

### 思路

我自己的做法挂了，暴力加剪枝，果然挂了，下面讲的是题解的算法。

解法一：优先队列

使用优先队列存储最大值，每一次滑动只需要在队首拿数据即可，我一开始也想到了优先队列，但是不知道删除的时机，所以不知道怎么写，其实不用急着删除，只需要保证队首的元素是在滑动窗口内就可以。

解法二：单调队列

如果窗口里面有a,b两个元素，a的下标比b小且值也比b小，这就意味着a用于不会有成为最大值的情况，因为窗口是从左到右移动的，如果a在窗口内则b也在窗口内。

所以我们可以构建一个单调队列来存储数据，单调队列内，元素的值是递减的，下标是递增的，可以从队首拿出滑动窗口的最大值。

当添加数据时，逐步弹出下标比它小并且值比它小的队列元素，拿出队首元素的时候，需要判断是否在滑动窗口内。

### 代码

优先队列

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    // 队列按最大值到最小值排列
    PriorityQueue<int[]> pq = new PriorityQueue<int[]>((o1,o2) -> o2[0]-o1[0]);
    // 更新第一个滑动窗口
    for (int i = 0; i < k; ++i) {
        pq.offer(new int[]{nums[i], i});
    }
    // 存储最大值
    int[] ans = new int[n - k + 1];
    ans[0] = pq.peek()[0];

    for (int i = k; i < n; ++i) {
        pq.offer(new int[]{nums[i], i});
        // 确保最大值在窗口内
        while (pq.peek()[1] <= i - k) {
            pq.poll();
        }
        ans[i - k + 1] = pq.peek()[0];
    }
    return ans;
}
```

单调队列

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    // 存储值递减的数据下标，下标是递增
    Deque<Integer> deque = new LinkedList<Integer>();
    // 每一个新值就往前遍历，将所有值比它小的弹出
    for (int i = 0; i < k; ++i) {
        // 重复弹出数据，直到遇到值比它大的或者队列为空
        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
            deque.pollLast();
        }
        // 放入数据，放最后一个是因为队列里面下标是递增的
        deque.offerLast(i);
    }

    int[] ans = new int[n - k + 1];
    // 因为队列里面的数据是递减的，所以只需要拿出第一个数据就是整个队列最大的数据
    ans[0] = nums[deque.peekFirst()];
    for (int i = k; i < n; ++i) {
        // 一样的更新队列操作
        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
            deque.pollLast();
        }
        deque.offerLast(i);
        // 保证队列的数据在窗口内
        while (deque.peekFirst() <= i - k) {
            deque.pollFirst();
        }
        ans[i - k + 1] = nums[deque.peekFirst()];
    }
    return ans;
}
```

## 2021/1/3

### 题目

[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

给你一个链表和一个特定值 `x` ，请你对链表进行分隔，使得所有小于 `x` 的节点都出现在大于或等于 `x` 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

 

**示例：**

```
输入：head = 1->4->3->2->5->2, x = 3
输出：1->2->2->4->3->5
```

### 思路

创建两个链表分别存储小于 x 和大于等于 x 的节点，然后拼接链表就可以了

### 代码

```java
public ListNode partition(ListNode head, int x) {
    // 空链表直接返回
    if(head == null){
        return head;
    }
    // 存储小于x的值
    ListNode small = new ListNode();
    ListNode stSmall = small;
    // 存储大于等于x的值
    ListNode big = new ListNode();
    ListNode stBig = big;

    while(head != null){
        if(head.val < x){
            small.next = head;
            small = small.next;
        }else{
            big.next = head;
            big = big.next;
        }
        head = head.next;
    }

    // 拿出首节点
    ListNode ans;
    if(stSmall.next != null){
        // 第一个节点是无效节点，需要跳过
        ans = stSmall.next;
        // 将大的拼接过去
        small.next = stBig.next;
        // 结尾设置为空
        big.next = null;
    }else{
        // 不存在小的就直接拿大的就可以了
        ans = stBig.next;
        big.next = null;
    }

    return ans;
}
```

## 2021/1/4

### 题目

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给你 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

 

**提示：**

- `0 <= n <= 30`

### 思路

斐波那契就没什么好说的，保留两个数即可

### 代码

```java
public int fib(int n) {
    if(n <= 1){
        return n;
    }
    // 保存前一个数
    int first = 0;
    // 保存当前结果
    int second = 1;
    // 临时保存当前结果
    int temp;
    // 记录第几个数
    int count = 1;
    while(count != n){
        temp = second;
        second = first + second;
        first = temp;
        count++;
    }

    return second;
}
```

## 2021/1/5

### 题目

[830. 较大分组的位置](https://leetcode-cn.com/problems/positions-of-large-groups/)



在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 `s = "abbxxxxzyy"` 中，就含有 `"a"`, `"bb"`, `"xxxx"`, `"z"` 和 `"yy"` 这样的一些分组。

分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `"xxxx"` 分组用区间表示为 `[3,6]` 。

我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。

找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。

 

**示例 1：**

```
输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
```

**示例 2：**

```
输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。
```

**示例 3：**

```
输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
```

**示例 4：**

```
输入：s = "aba"
输出：[]
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅含小写英文字母

### 思路

很简单的题，就遍历，然后看看连续的字符数量是否大于3，如果大于3就加入。

提交以后发现空间复杂度不是很理想，我想我也没用几个东西啊，然后就换一种方法，换成双指针，提交上去发现也差不了多少。然后才想起来，力扣的提交，时间和空间是有误差的，由于数据小，误差有时候就很明显。

这里把两份代码都贴上来吧，虽然两份代码性能都差不多，但是双指针的比较直观好理解

### 代码

正常解法

```java
// 正常遍历
public List<List<Integer>> largeGroupPositions(String s) {
    List<List<Integer>> ans = new ArrayList<>();
    int len = s.length();
    // 注意，for里面 i 没有递增
    for(int i = 0; i < s.length() - 1;){
        int count = 1;

        // 寻找重复的数据
        while(i + count < len && s.charAt(i) == s.charAt(i + count)){
            count++;
        }

        // 大于3添加
        if(count >= 3){
            ans.add(List.of(i,i+count - 1));
        }

        // 跳过重复的数据
        i = i + count;
    }

    return ans;
}
```

双指针

```java
// 双指针
public List<List<Integer>> largeGroupPositions(String s) {
    int st = 0;
    int len = s.length();
    List<List<Integer>> ans = new ArrayList<>();

    while(st < len){
        int ed = st + 1;
        // 判断是否和起始相等
        while(ed < len && s.charAt(st) == s.charAt(ed)){
            ed++;
        }
        // 判断是否大于等于3
        if(ed - st >= 3){
            ans.add(List.of(st,ed-1));
        }
   		// 跳过重复的
        st = ed;
    }

    return ans;
}
```

## 2021/1/6

### 题目

[399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。

 

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

 

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

**示例 2：**

```
输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]
```

**示例 3：**

```
输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
输出：[0.50000,2.00000,-1.00000,-1.00000]
```

 

**提示：**

- `1 <= equations.length <= 20`
- `equations[i].length == 2`
- `1 <= Ai.length, Bi.length <= 5`
- `values.length == equations.length`
- `0.0 < values[i] <= 20.0`
- `1 <= queries.length <= 20`
- `queries[i].length == 2`
- `1 <= Cj.length, Dj.length <= 5`
- `Ai, Bi, Cj, Dj` 由小写英文字母与数字组成

### 思路

我自己的思路是模拟，假如a / b = 2，则设置 a = 2x~1~，b = x~1~，x~1~是一个组别，为了处理数据出来的先后而设置的，比如 a / b = 2，c / d = 2，a / c = 2，如果一开始设置 a = 2，b = 1，c = 2，d = 1，那 a / c 就矛盾了，如果按我的方法，a = 2x~1~，b = 1x~1~，c = 2x~2~，d = 1x~2~，只需要在再搭建一个x~1~ 到 x~2~ 的桥梁即可。

如果两个节点都没有组别，则创建一个新的组别给他们，如果其中一个有组别了，则使用这个组别给另外一个赋值，如果都有组别则搭建一个组别之间的桥梁，这样就把所有的关系连接起来了。

判别的时候

- 如果问题数据两个都不存在组别则输出-1.0
- 两个结点相等就输出1.0（这一步判定需要放在上一步后面）
- 否则拿出各自组别，然后判断组别是否相等
  - 相等的话，直接值相除
  - 否则，拿出桥梁，通过桥梁计算

题解的思路更加清晰，把各个结点连接成一个图，然后通过图来计算点到点的距离，好久没遇到图的题目了，一时间没想起这种做法

看是中等题，做是困难题，题解中等题

### 代码

模拟

```java
public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    int len = equations.size();
    // 使用一个Map来存储所有的对应关系
    Map<String,Double> relation = new HashMap<>();
    // 表示现在已有多少个不同的对应关系
    int count = 1;

    // 创造对应关系
    for(int i = 0; i < len; i++){
        // 拿出两个变量
        String val1 = equations.get(i).get(0);
        String val2 = equations.get(i).get(1);
        // 对应关系里面的值
        double reVal1;
        double reVal2;

        // 查看两个数据是否已经有对应关系
        // 两个数据都没有
        if(!relation.containsKey(val1) && !relation.containsKey(val2)){
            // 加上的数字为所在的组别, 默认设置val2为1
            relation.put(val1,values[i] + count * 100000);
            relation.put(val2, 1 + (double)count * 100000);
            count++;
        }else if(relation.containsKey(val1) && relation.containsKey(val2)){
            // 两个数据都包含
            reVal1 = relation.get(val1);
            reVal2 = relation.get(val2);
            // 拿出组别
            int group1 = ((int)reVal1/100000) * 100000;
            int group2 = ((int)reVal2/100000) * 100000;
            // 如果这两个是同一组，则意味着这是一条无用等式，信息前面都给过了,题意说了不会给矛盾的数据，所以不用管
            // 两个组别不一致，生成组别对应关系
            if(group1 != group2){
                // 不存在组别对应关系才创建对应关系
                if(!relation.containsKey(String.valueOf(group1)) || !relation.containsKey(String.valueOf(group2))){
                    reVal1 = reVal1 % 100000;
                    reVal2 = reVal2 % 100000;
                    relation.put(String.valueOf(group1),(values[i] * reVal2) / reVal1);
                    relation.put(String.valueOf(group2),reVal1 / (values[i] * reVal2));
                }

            }
        }else if(relation.containsKey(val1)){
            // 先拿出组别
            int group = (int)((relation.get(val1)) / 100000);
            // 只包含val1
            relation.put(val2,(relation.get(val1) % 100000 / values[i]) + group * 100000);
        }else{
            // 先拿出组别
            int group = (int)((relation.get(val2)) / 100000);
            // 只包含val2
            relation.put(val1,(relation.get(val2) % 100000) * values[i] + group * 100000);
        }
    }

    // 根据对应关系算答案
    len = queries.size();
    double[] ans = new double[len];
    for(int i = 0; i < len; i++){
        // 拿出变量
        String val1 = queries.get(i).get(0);
        String val2 = queries.get(i).get(1);
        // 拿出变量对应关系
        double reVal1 = relation.getOrDefault(val1,0.12345);
        double reVal2 = relation.getOrDefault(val2,0.12345);
        // 如果有一个数不存在，则直接设置为0
        if(reVal1 - 0.12345 < 0.000001 || reVal2 - 0.12345 < 0.000001){
            ans[i] = -1.0;
            continue;
        }
        // 拿出组别
        int group1 = (int)reVal1 / 100000;
        int group2 = (int)reVal2 / 100000;

        // 去除组别
        reVal1 = reVal1 % 100000;
        reVal2 = reVal2 % 100000;

        // 组别相等直接除
        if(group1 == group2){
            ans[i] = reVal1 / reVal2;
        }else{
            // 组别不等就取出组别对应关系
            double theRelation = relation.getOrDefault(String.valueOf(group1 * 100000),0.12345);
            // 如果没有对应关系就设置为-1.0
            if(Math.abs(theRelation - 0.12345) < 0.00000001){
                ans[i] = -1.0;
            }else{
                ans[i] = reVal1 * theRelation / reVal2;
            }
        }
    }

    return ans;
}
```

题解，图 + Floyd

```java
public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    int nvars = 0;
    // 使用哈希表来让字符串和数字对应起来
    Map<String, Integer> variables = new HashMap<String, Integer>();

    int n = equations.size();
    for (int i = 0; i < n; i++) {
        // 没有对应的节点则创建一个
        if (!variables.containsKey(equations.get(i).get(0))) {
            variables.put(equations.get(i).get(0), nvars++);
        }
        if (!variables.containsKey(equations.get(i).get(1))) {
            variables.put(equations.get(i).get(1), nvars++);
        }
    }
    // 点到点的距离
    double[][] graph = new double[nvars][nvars];
    // 填充值
    for (int i = 0; i < nvars; i++) {
        Arrays.fill(graph[i], -1.0);
    }
    // 初始化图
    for (int i = 0; i < n; i++) {
        int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));
        graph[va][vb] = values[i];
        graph[vb][va] = 1.0 / values[i];
    }
	// 通过初始化的值来计算所有节点之间的关系
    for (int k = 0; k < nvars; k++) {
        for (int i = 0; i < nvars; i++) {
            for (int j = 0; j < nvars; j++) {
                // 没有初始化的节点跳过
                if (graph[i][k] > 0 && graph[k][j] > 0) {
                    graph[i][j] = graph[i][k] * graph[k][j];
                }
            }
        }
    }

    int queriesCount = queries.size();
    double[] ret = new double[queriesCount];
    for (int i = 0; i < queriesCount; i++) {
        List<String> query = queries.get(i);
        double result = -1.0;
        // 节点都有对应关系才计算
        if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {
            // 拿出字符串对应的数字
            int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));
            if (graph[ia][ib] > 0) {
                result = graph[ia][ib];
            }
        }
        ret[i] = result;
    }
    return ret;
}
```

## 2021/1/7

### 题目

[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

难度中等398收藏分享切换为英文接收动态反馈

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)

```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)

```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```

 

**提示：**

- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` 为 `1` 或 `0`
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`

### 思路

遍历每个没有遍历过的节点，遍历节点的时候，把所有相关的都遍历一遍，就是深搜啦，深搜的次数就是答案

### 代码

```java
// 全局变量
int[][] map;
int len;

// 主方法
public int findCircleNum(int[][] isConnected) {
    len = isConnected.length;
    // 标记某个点是否遍历过
    boolean[] used = new boolean[len];
    map = isConnected;
    int ans = 0;

    for(int i = 0; i < len; i++){
        // 没遍历过就遍历
        if(!used[i]){
            find(i,used);
            ans++;
        }
    }

    return ans;
}

// 深搜方法
public void find(int index,boolean[] used){
    used[index] = true;
    // 把所有相关的点遍历一遍
    for(int i = 0; i < len; i++){
        if(!used[i] && map[index][i] == 1){
            find(i,used);
        }
    }
}
```

## 2021/1/8

### 题目

[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。

 

**进阶：**

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？

 

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

 

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

### 思路

将向左转换为向右，然后数组移位即可

### 代码

```java
public void rotate(int[] nums, int k) {
    int len = nums.length;
    // 移动一步和移动len + 1步是一样的
    k %= len;
    // 如果等于0，就等于没动
    if(k == 0){
        return;
    }
    // 转换成向右移动
    k = len - k;
    // 存储临时数据
    int[] data = new int[k];
    System.arraycopy(nums,0,data,0,k);
    // 后面数据向前移动
    System.arraycopy(nums, k, nums, 0, len - k);
    // 填充后面数据
    System.arraycopy(data,0,nums,len - k, k);
}
```



## 2021/1/9

### 题目

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 105`

### 思路

维护四个状态

- 第一次进行股票购买, buy1
- 第一次进行股票出售, buy2
- 第二次进行股票购买, sell1
- 第二次进行股票出售, sell2

由于不限制当天买入当天卖出，所以对于[1,2,3,4,5,6]也没有影响

三言两语解释不是很清楚，还是看题解吧。

### 代码

```java
// 题目并不限制在一天之内买入并卖出
public int maxProfit(int[] prices) {
    int n = prices.length;
    // buy1,sell1,buy2,sell2
    // 分别代表当天买入，当天卖出，当买入卖出的情况下再买入，在买入卖出的情况下再卖出
    int buy1 = -prices[0], sell1 = 0;
    int buy2 = -prices[0], sell2 = 0;
    for (int i = 1; i < n; ++i) {
        buy1 = Math.max(buy1, -prices[i]);
        sell1 = Math.max(sell1, buy1 + prices[i]);
        buy2 = Math.max(buy2, sell1 - prices[i]);
        sell2 = Math.max(sell2, buy2 + prices[i]);
    }
    return sell2;
}
```

## 2021/1/10

### 题目

[228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

给定一个无重复元素的有序整数数组 `nums` 。

返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

 

**示例 1：**

```
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

**示例 2：**

```
输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

**示例 3：**

```
输入：nums = []
输出：[]
```

**示例 4：**

```
输入：nums = [-1]
输出：["-1"]
```

**示例 5：**

```
输入：nums = [0]
输出：["0"]
```

 

**提示：**

- `0 <= nums.length <= 20`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中的所有值都 **互不相同**
- `nums` 按升序排列

### 思路

双指针遍历，即可，只要前一个的数据比当前大1，则第二个指针自增1，其实单指针就行了，第一个指针没什么用处，

### 代码

```java
public List<String> summaryRanges(int[] nums) {
    List<String> ans = new LinkedList<>();
    int len = nums.length;
    if(len == 0){
        return ans;
    }
    // 区间开始位置
    int first = 0;
    // 区间结束位置
    int second;
    while (first < len){
        second = first + 1;
        while(second < len && nums[second] == nums[second-1] + 1){
            second++;
        }
        StringBuilder sb = new StringBuilder(String.valueOf(nums[first]));
        if(first != second - 1){
            ans.add(sb.append("->").append(nums[second]).toString());
        }else{
            ans.add(sb.toString());
        }
        first = second;
    }
    return ans;
}
```

## 2021/1/11

### 题目

[1202. 交换字符串中的元素](https://leetcode-cn.com/problems/smallest-string-with-swaps/)

给你一个字符串 `s`，以及该字符串中的一些「索引对」数组 `pairs`，其中 `pairs[i] = [a, b]` 表示字符串中的两个索引（编号从 0 开始）。

你可以 **任意多次交换** 在 `pairs` 中任意一对索引处的字符。

返回在经过若干次交换后，`s` 可以变成的按字典序最小的字符串。

 

**示例 1:**

```
输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
```

**示例 2：**

```
输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]
输出："abcd"
解释：
交换 s[0] 和 s[3], s = "bcad"
交换 s[0] 和 s[2], s = "acbd"
交换 s[1] 和 s[2], s = "abcd"
```

**示例 3：**

```
输入：s = "cba", pairs = [[0,1],[1,2]]
输出："abc"
解释：
交换 s[0] 和 s[1], s = "bca"
交换 s[1] 和 s[2], s = "bac"
交换 s[0] 和 s[1], s = "abc"
```

 

**提示：**

- `1 <= s.length <= 10^5`
- `0 <= pairs.length <= 10^5`
- `0 <= pairs[i][0], pairs[i][1] < s.length`
- `s` 中只含有小写英文字母

### 思路

唉，周赛的题还是绕不过去，这题和周赛的差不多，就是简单一些。思路如下，

只要两个节点能相互交换就将他们放在同一个联通子集中，然后给每一个联通子集一个优先队列，用来弹出最小的字符。

### 代码

```java
public class LC1202 {
    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
        // 天道好轮回，想避避不了，还是得写这样的题
        int len = s.length();
        // 新建并查集
        UnionFind uf = new UnionFind(len);
        // 将数据添加到并查集中
        for(List<Integer> data : pairs){
            uf.union(data.get(0),data.get(1));
        }
        // 给每个并查集一个优先队列
        Map<Integer, PriorityQueue<Character>> m = new HashMap<>();
        // 将数据放进每个并查集对应的优先队列中
        for(int i = 0;i < len; i++){
            // 根据并查集来找出源节点，如果源节点在哈希表中没有对应的优先队列，则创建一个并返回，然后将数据存入
            m.computeIfAbsent(uf.find(i), key -> new PriorityQueue<>()).offer(s.charAt(i));
        }
        // 重组数据
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < len; i++){
            // 查找当前节点对应的源节点的优先队列，弹出队首（最小的）添加到字符串中
            sb.append(m.get(uf.find(i)).poll());
        }

        return sb.toString();
    }
}

class UnionFind{
    /**
     * 存储各个节点的父节点
     */
    private int[] parents;

    UnionFind(int len){
        parents = new int[len];
        this.init();
    }

    // 寻找起始节点并将原来不是连接在起始节点的连接上来
    public int find(int index){
        if(index == parents[index]){
            return index;
        }

        // 顺便将子节点直接连接到父节点上
        return parents[index] = find(parents[index]);
    }

    // 将每个节点一开始的起始节点初始化为自己
    private void init(){
        for(int i = 0; i < parents.length; i++){
            parents[i] = i;
        }
    }

    // 将两个节点连接在一起
    public void union(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        // 结点不一致将root2所在的连通分支接到root1上
        if(root1 != root2){
            parents[root2] = root1;
        }
    }

}
```

## 2021/1/12

### 题目

[1203. 项目管理](https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/)

公司共有 `n` 个项目和  `m` 个小组，每个项目要不无人接手，要不就由 `m` 个小组之一负责。

`group[i]` 表示第 `i` 个项目所属的小组，如果这个项目目前无人接手，那么 `group[i]` 就等于 `-1`。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。

请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：

- 同一小组的项目，排序后在列表中彼此相邻。
- 项目之间存在一定的依赖关系，我们用一个列表 `beforeItems` 来表示，其中 `beforeItems[i]` 表示在进行第 `i` 个项目前（位于第 `i` 个项目左侧）应该完成的所有项目。

如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 **空列表** 。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/22/1359_ex1.png)**

```
输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
输出：[6,3,4,1,5,2,0,7]
```

**示例 2：**

```
输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
输出：[]
解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。
```

 

**提示：**

- `1 <= m <= n <= 3 * 104`
- `group.length == beforeItems.length == n`
- `-1 <= group[i] <= m - 1`
- `0 <= beforeItems[i].length <= n - 1`
- `0 <= beforeItems[i][j] <= n - 1`
- `i != beforeItems[i][j]`
- `beforeItems[i]` 不含重复元素

### 思路

无思路，今天这道题是真的不会，可以去期末复习了

### 代码

题解代码

```java
class Solution {
    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {
        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();
        for (int i = 0; i < n + m; ++i) {
            groupItem.add(new ArrayList<Integer>());
        }

        // 组间和组内依赖图
        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();
        for (int i = 0; i < n + m; ++i) {
            groupGraph.add(new ArrayList<Integer>());
        }
        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();
        for (int i = 0; i < n; ++i) {
            itemGraph.add(new ArrayList<Integer>());
        }

        // 组间和组内入度数组
        int[] groupDegree = new int[n + m];
        int[] itemDegree = new int[n];
        
        List<Integer> id = new ArrayList<Integer>();
        for (int i = 0; i < n + m; ++i) {
            id.add(i);
        }

        int leftId = m;
        // 给未分配的 item 分配一个 groupId
        for (int i = 0; i < n; ++i) {
            if (group[i] == -1) {
                group[i] = leftId;
                leftId += 1;
            }
            groupItem.get(group[i]).add(i);
        }
        // 依赖关系建图
        for (int i = 0; i < n; ++i) {
            int curGroupId = group[i];
            for (int item : beforeItems.get(i)) {
                int beforeGroupId = group[item];
                if (beforeGroupId == curGroupId) {
                    itemDegree[i] += 1;
                    itemGraph.get(item).add(i);   
                } else {
                    groupDegree[curGroupId] += 1;
                    groupGraph.get(beforeGroupId).add(curGroupId);
                }
            }
        }

        // 组间拓扑关系排序
        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); 
        if (groupTopSort.size() == 0) {
            return new int[0];
        }
        int[] ans = new int[n];
        int index = 0;
        // 组内拓扑关系排序
        for (int curGroupId : groupTopSort) {
            int size = groupItem.get(curGroupId).size();
            if (size == 0) {
                continue;
            }
            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));
            if (res.size() == 0) {
                return new int[0];
            }
            for (int item : res) {
                ans[index++] = item;
            }
        }
        return ans;
    }

    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {
        Queue<Integer> queue = new LinkedList<Integer>();
        for (int item : items) {
            if (deg[item] == 0) {
                queue.offer(item);
            }
        }
        List<Integer> res = new ArrayList<Integer>();
        while (!queue.isEmpty()) {
            int u = queue.poll(); 
            res.add(u);
            for (int v : graph.get(u)) {
                if (--deg[v] == 0) {
                    queue.offer(v);
                }
            }
        }
        return res.size() == items.size() ? res : new ArrayList<Integer>();
    }
}
```

## 2021/1/13

### 题目

[684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1：**

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2：**

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意:**

- 输入的二维数组大小在 3 到 1000。
- 二维数组中的整数在1到N之间，其中N是输入数组的大小。

### 思路

继续用昨天并查集做，遍历每个节点对并查找他们的源节点，如果源节点相同，则代表它们在之前就连接过了，再加入会导致环，把他们当成答案返回，否则就连接两个节点，题目保证会产生环，所以不用其他处理。

我觉得有点问题

> 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`

但是我代码写的是先出现先返回，还是过了，如果要返回最后一个，得把所有会产生环的边存起来再返回最后一个。

### 代码

并查集的代码和昨天一样，就不贴了

```java
public int[] findRedundantConnection(int[][] edges) {
    int len = edges.length;
    UnionFind uf = new UnionFind(len+1);

    for(int[] data : edges){
        // 寻找两个节点的源节点
        int root1 = uf.find(data[0]);
        int root2 = uf.find(data[1]);
        // 不是同一个就合并，是同一个就代表加入会产生环，返回
        if(root1 != root2){
            uf.union(root1,root2);
        }else{
            return new int[]{data[0],data[1]};
        }
    }

    return new int[]{0,0};
}
```

## 2021/1/14

### 题目

[1018. 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)

给定由若干 `0` 和 `1` 组成的数组 `A`。我们定义 `N_i`：从 `A[0]` 到 `A[i]` 的第 `i` 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。

返回布尔值列表 `answer`，只有当 `N_i` 可以被 `5` 整除时，答案 `answer[i]` 为 `true`，否则为 `false`。

**示例 1：**

```
输入：[0,1,1]
输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。
```

**示例 2：**

```
输入：[1,1,1]
输出：[false,false,false]
```

**示例 3：**

```
输入：[0,1,1,1,1,1]
输出：[true,false,false,false,true,false]
```

**示例 4：**

```
输入：[1,1,1,0,1]
输出：[false,false,false,false,false]
```

**提示：**

1. `1 <= A.length <= 30000`
2. `A[i]` 为 `0` 或 `1`

### 思路

从头遍历到尾，计算出前面当前二进制的值即可，注意，每一次计算机的模5,5比较特殊，可以这么计算，不然总值会超出长度

### 代码

```java
public List<Boolean> prefixesDivBy5(int[] A) {
    int len = A.length;
    int sum = 0;
    List<Boolean> ans = new LinkedList<>();

    for (int j : A) {
        sum <<= 1;
        sum += j;
        sum %= 5;
        ans.add(sum == 0);
    }

    return ans;
}
```

## 2021/1/15

### 题目

[947. 移除最多的同行或同列石头](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/)

`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 `n` 的数组 `stones` ，其中 `stones[i] = [xi, yi]` 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。

 

**示例 1：**

```
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

**示例 2：**

```
输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
```

**示例 3：**

```
输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
```

 

**提示：**

- `1 <= stones.length <= 1000`
- `0 <= xi, yi <= 104`
- 不会有两块石头放在同一个坐标点上

### 思路

要考试了，今天暂时鸽了，cv题解的，考完试回来补上，后面几天应该也是一样

### 代码

```java
public int removeStones(int[][] stones) {
    UnionFind unionFind = new UnionFind();

    for (int[] stone : stones) {
        // 下面这三种写法任选其一
        // unionFind.union(~stone[0], stone[1]);
        // unionFind.union(stone[0] - 10001, stone[1]);
        unionFind.union(stone[0] + 10001, stone[1]);
    }
    return stones.length - unionFind.getCount();
}

private class UnionFind {

    private Map<Integer, Integer> parent;
    private int count;

    public UnionFind() {
        this.parent = new HashMap<>();
        this.count = 0;
    }

    public int getCount() {
        return count;
    }

    public int find(int x) {
        if (!parent.containsKey(x)) {
            parent.put(x, x);
            count++;
        }

        if (x != parent.get(x)) {
            parent.put(x, find(parent.get(x)));
        }
        return parent.get(x);
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }

        parent.put(rootX, rootY);
        count--;
    }
}
```

## 2021/1/16

### 题目

[803. 打砖块](https://leetcode-cn.com/problems/bricks-falling-when-hit/)

有一个 `m x n` 的二元网格，其中 `1` 表示砖块，`0` 表示空白。砖块 **稳定**（不会掉落）的前提是：

- 一块砖直接连接到网格的顶部，或者
- 至少有一块相邻（4 个方向之一）砖块 **稳定** 不会掉落时

给你一个数组 `hits` ，这是需要依次消除砖块的位置。每当消除 `hits[i] = (rowi, coli)` 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。

返回一个数组 `result` ，其中 `result[i]` 表示第 `i` 次消除操作对应掉落的砖块数目。

**注意**，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。

 

**示例 1：**

```
输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
输出：[2]
解释：
网格开始为：
[[1,0,0,0]，
 [1,1,1,0]]
消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0]
 [0,1,1,0]]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
[[1,0,0,0],
 [0,0,0,0]]
因此，结果为 [2] 。
```

**示例 2：**

```
输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
输出：[0,0]
解释：
网格开始为：
[[1,0,0,0],
 [1,1,0,0]]
消除 (1,1) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [1,0,0,0]]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
[[1,0,0,0], 
 [1,0,0,0]]
接下来消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [0,0,0,0]]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 [0,0] 。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `grid[i][j]` 为 `0` 或 `1`
- `1 <= hits.length <= 4 * 104`
- `hits[i].length == 2`
- `0 <= xi <= m - 1`
- `0 <= yi <= n - 1`
- 所有 `(xi, yi)` 互不相同

### 思路

今天依旧余着

### 代码

```java
public class Solution {

    private int rows;
    private int cols;

    public static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};

    public int[] hitBricks(int[][] grid, int[][] hits) {
        this.rows = grid.length;
        this.cols = grid[0].length;

        // 第 1 步：把 grid 中的砖头全部击碎，通常算法问题不能修改输入数据，这一步非必需，可以认为是一种答题规范
        int[][] copy = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                copy[i][j] = grid[i][j];
            }
        }

        // 把 copy 中的砖头全部击碎
        for (int[] hit : hits) {
            copy[hit[0]][hit[1]] = 0;
        }

        // 第 2 步：建图，把砖块和砖块的连接关系输入并查集，size 表示二维网格的大小，也表示虚拟的「屋顶」在并查集中的编号
        int size = rows * cols;
        UnionFind unionFind = new UnionFind(size + 1);

        // 将下标为 0 的这一行的砖块与「屋顶」相连
        for (int j = 0; j < cols; j++) {
            if (copy[0][j] == 1) {
                unionFind.union(j, size);
            }
        }

        // 其余网格，如果是砖块向上、向左看一下，如果也是砖块，在并查集中进行合并
        for (int i = 1; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (copy[i][j] == 1) {
                    // 如果上方也是砖块
                    if (copy[i - 1][j] == 1) {
                        unionFind.union(getIndex(i - 1, j), getIndex(i, j));
                    }
                    // 如果左边也是砖块
                    if (j > 0 && copy[i][j - 1] == 1) {
                        unionFind.union(getIndex(i, j - 1), getIndex(i, j));
                    }
                }
            }
        }

        // 第 3 步：按照 hits 的逆序，在 copy 中补回砖块，把每一次因为补回砖块而与屋顶相连的砖块的增量记录到 res 数组中
        int hitsLen = hits.length;
        int[] res = new int[hitsLen];
        for (int i = hitsLen - 1; i >= 0; i--) {
            int x = hits[i][0];
            int y = hits[i][1];

            // 注意：这里不能用 copy，语义上表示，如果原来在 grid 中，这一块是空白，这一步不会产生任何砖块掉落
            // 逆向补回的时候，与屋顶相连的砖块数量也肯定不会增加
            if (grid[x][y] == 0) {
                continue;
            }

            // 补回之前与屋顶相连的砖块数
            int origin = unionFind.getSize(size);

            // 注意：如果补回的这个结点在第 1 行，要告诉并查集它与屋顶相连（逻辑同第 2 步）
            if (x == 0) {
                unionFind.union(y, size);
            }

            // 在 4 个方向上看一下，如果相邻的 4 个方向有砖块，合并它们
            for (int[] direction : DIRECTIONS) {
                int newX = x + direction[0];
                int newY = y + direction[1];

                if (inArea(newX, newY) && copy[newX][newY] == 1) {
                    unionFind.union(getIndex(x, y), getIndex(newX, newY));
                }
            }

            // 补回之后与屋顶相连的砖块数
            int current = unionFind.getSize(size);
            // 减去的 1 是逆向补回的砖块（正向移除的砖块），与 0 比较大小，是因为存在一种情况，添加当前砖块，不会使得与屋顶连接的砖块数更多
            res[i] = Math.max(0, current - origin - 1);

            // 真正补上这个砖块
            copy[x][y] = 1;
        }
        return res;
    }

    /**
     * 输入坐标在二维网格中是否越界
     *
     * @param x
     * @param y
     * @return
     */
    private boolean inArea(int x, int y) {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }

    /**
     * 二维坐标转换为一维坐标
     *
     * @param x
     * @param y
     * @return
     */
    private int getIndex(int x, int y) {
        return x * cols + y;
    }

    private class UnionFind {

        /**
         * 当前结点的父亲结点
         */
        private int[] parent;
        /**
         * 以当前结点为根结点的子树的结点总数
         */
        private int[] size;

        public UnionFind(int n) {
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        /**
         * 路径压缩，只要求每个不相交集合的「根结点」的子树包含的结点总数数值正确即可，因此在路径压缩的过程中不用维护数组 size
         *
         * @param x
         * @return
         */
        public int find(int x) {
            if (x != parent[x]) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);

            if (rootX == rootY) {
                return;
            }
            parent[rootX] = rootY;
            // 在合并的时候维护数组 size
            size[rootY] += size[rootX];
        }

        /**
         * @param x
         * @return x 在并查集的根结点的子树包含的结点总数
         */
        public int getSize(int x) {
            int root = find(x);
            return size[root];
        }
    }
}

```

## 2021/1/17

### 题目

[1232. 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/)

在一个 XY 坐标系中有一些点，我们用数组 `coordinates` 来分别记录它们的坐标，其中 `coordinates[i] = [x, y]` 表示横坐标为 `x`、纵坐标为 `y` 的点。

请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 `true`，否则请返回 `false`。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg)

```
输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
输出：true
```

**示例 2：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg)**

```
输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
输出：false
```



**提示：**

- `2 <= coordinates.length <= 1000`
- `coordinates[i].length == 2`
- `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`
- `coordinates` 中不含重复的点

### 思路

考试

### 代码

```java
public boolean checkStraightLine(int[][] coordinates) {
    int deltaX = coordinates[0][0], deltaY = coordinates[0][1];
    int n = coordinates.length;
    for (int i = 0; i < n; i++) {
        coordinates[i][0] -= deltaX;
        coordinates[i][1] -= deltaY;
    }
    int A = coordinates[1][1], B = -coordinates[1][0];
    for (int i = 2; i < n; i++) {
        int x = coordinates[i][0], y = coordinates[i][1];
        if (A * x + B * y != 0) {
            return false;
        }
    }
    return true;
}
```

## 2021/1/18

### 题目

[721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)

给定一个列表 `accounts`，每个元素 `accounts[i]` 是一个字符串列表，其中第一个元素 `accounts[i][0]` 是 *名称 (name)*，其余元素是 *emails* 表示该账户的邮箱地址。

现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。

合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。

 

**示例 1：**

```
输入：
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
输出：
[["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
解释：
第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 "johnsmith@mail.com"。 
第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。
可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，
['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。
```

 

**提示：**

- `accounts`的长度将在`[1，1000]`的范围内。
- `accounts[i]`的长度将在`[1，10]`的范围内。
- `accounts[i][j]`的长度将在`[1，30]`的范围内。

### 思路

考试

### 代码

```java
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    Map<String, Integer> emailToIndex = new HashMap<String, Integer>();
    Map<String, String> emailToName = new HashMap<String, String>();
    int emailsCount = 0;
    for (List<String> account : accounts) {
        String name = account.get(0);
        int size = account.size();
        for (int i = 1; i < size; i++) {
            String email = account.get(i);
            if (!emailToIndex.containsKey(email)) {
                emailToIndex.put(email, emailsCount++);
                emailToName.put(email, name);
            }
        }
    }
    UnionFind uf = new UnionFind(emailsCount);
    for (List<String> account : accounts) {
        String firstEmail = account.get(1);
        int firstIndex = emailToIndex.get(firstEmail);
        int size = account.size();
        for (int i = 2; i < size; i++) {
            String nextEmail = account.get(i);
            int nextIndex = emailToIndex.get(nextEmail);
            uf.union(firstIndex, nextIndex);
        }
    }
    Map<Integer, List<String>> indexToEmails = new HashMap<Integer, List<String>>();
    for (String email : emailToIndex.keySet()) {
        int index = uf.find(emailToIndex.get(email));
        List<String> account = indexToEmails.getOrDefault(index, new ArrayList<String>());
        account.add(email);
        indexToEmails.put(index, account);
    }
    List<List<String>> merged = new ArrayList<List<String>>();
    for (List<String> emails : indexToEmails.values()) {
        Collections.sort(emails);
        String name = emailToName.get(emails.get(0));
        List<String> account = new ArrayList<String>();
        account.add(name);
        account.addAll(emails);
        merged.add(account);
    }
    return merged;
}
}

class UnionFind {
    int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public void union(int index1, int index2) {
        parent[find(index2)] = find(index1);
    }

    public int find(int index) {
        if (parent[index] != index) {
            parent[index] = find(parent[index]);
        }
        return parent[index];
    }
```

