---
title: 力扣每日一题
top: 1
date: 2020-12-11 20:24:58
tags:
- 算法
---

## 前言

之前每日一题的markdown文件不知道哪去了，只能重新开始写，以后记得备份文件！

<!-- more -->

## 2020/12/11

### 题目

[649. Dota2 参议院](https://leetcode-cn.com/problems/dota2-senate/)

难度中等173收藏分享切换为英文接收动态反馈

Dota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的`**一**`项：

1. `禁止一名参议员的权利`：

   参议员可以让另一位参议员在这一轮和随后的几轮中丧失**所有的权利**。

2. `宣布胜利`：

​     如果参议员发现有权利投票的参议员都是**同一个阵营的**，他可以宣布胜利并决定在游戏中的有关变化。

 

给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。

 

**示例 1：**

```
输入："RD"
输出："Radiant"
解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
```

**示例 2：**

```
输入："RDD"
输出："Dire"
解释：
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

 

**提示：**

- 给定字符串的长度在 `[1, 10,000]` 之间.

### 思路

贪心算法解决，每一个有票的人，只需要干掉离自己最近的对方阵营的人即可，当一个阵营没人，留下来的就是胜利的！

### 代码

```java
public String predictPartyVictory(String senate){
    int len  = senate.length();
    boolean[] used = new boolean[len];
    int RLen=0,DLen=0,RNum=0,DNum=0;

    // 更新人数
    for(int i = 0; i < len; i++){
        if(senate.charAt(i) == 'D'){
            DNum++;
        }else{
            RNum++;
        }
    }

    while(RNum > 0 && DNum > 0){
        for(int i = 0; i < len && RNum > 0 && DNum > 0; i++){
            if(!used[i]){
                if(senate.charAt(i) == 'R'){
                    if(DLen > 0){
                        DLen--;
                        used[i] = true;
                        RNum--;
                    }else{
                        RLen++;
                    }
                }else{
                    if(RLen > 0){
                        RLen--;
                        used[i] = true;
                        DNum--;
                    }else{
                        DLen++;
                    }
                }
            }
        }
    }

    return DNum > 0 ? "Dire" : "Radiant";
}
```

## 2020/12/12

### 题目

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度中等321收藏分享切换为英文接收动态反馈

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 O(*n*) 时间复杂度完成此题?

### 思路

采用DP，从头到尾递推即可。

使用两个变量，hLen表示升序序列长度，lLen表示降序序列长度，都初始化为1

如果当前的数据比前一个数据大，则更新hLen，hLen = max(lLen + 1 , hLen)，如果比前一个数据小，则更新lLen，lLen = max(hLen + 1, lLen)。

为什么可以用前一个数据代替摆动数列的尾部呢？因为如果这一次比较无法更新数据，则用当前数据顶替尾部数据，例如当前摆动数列的尾部为7（上升），升序长度为10，当前数据为9，更新降序长度后，因为升序的下一个只能找降序，所以用10顶替7没有问题。

### 代码

```java
public int wiggleMaxLength(int[] nums){
    int len = nums.length;
    if(len < 2){
        return len;
    }

    int hLen = 1;          // 存储升序的长度
    int lLen = 1;          // 存储降序的长度

    for(int i = 1; i < len; i++){
        if(nums[i] > nums[i-1]){
            hLen = Math.max(lLen+1,hLen);
        }else if(nums[i] < nums[i-1]){
            lLen = Math.max(hLen+1,lLen);
        }
    }

    return Math.max(hLen,lLen);
}
```



