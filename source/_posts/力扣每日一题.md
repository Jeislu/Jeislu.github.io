---
title: 力扣每日一题
date: 2020-12-11 20:24:58
tags:
- 算法
---

## 前言

之前每日一题的markdown文件不知道哪去了，只能重新开始写，以后记得备份文件！

记录本人力扣每日一题的思路

<!-- more -->

## 2020/12/11

### 题目

[649. Dota2 参议院](https://leetcode-cn.com/problems/dota2-senate/)

难度中等173收藏分享切换为英文接收动态反馈

Dota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的`**一**`项：

1. `禁止一名参议员的权利`：

   参议员可以让另一位参议员在这一轮和随后的几轮中丧失**所有的权利**。

2. `宣布胜利`：

​     如果参议员发现有权利投票的参议员都是**同一个阵营的**，他可以宣布胜利并决定在游戏中的有关变化。

 

给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。

 

**示例 1：**

```
输入："RD"
输出："Radiant"
解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
```

**示例 2：**

```
输入："RDD"
输出："Dire"
解释：
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

 

**提示：**

- 给定字符串的长度在 `[1, 10,000]` 之间.

### 思路

贪心算法解决，每一个有票的人，只需要干掉离自己最近的对方阵营的人即可，当一个阵营没人，留下来的就是胜利的！

### 代码

```java
public String predictPartyVictory(String senate){
    int len  = senate.length();
    boolean[] used = new boolean[len];
    int RLen=0,DLen=0,RNum=0,DNum=0;

    // 更新人数
    for(int i = 0; i < len; i++){
        if(senate.charAt(i) == 'D'){
            DNum++;
        }else{
            RNum++;
        }
    }

    while(RNum > 0 && DNum > 0){
        for(int i = 0; i < len && RNum > 0 && DNum > 0; i++){
            if(!used[i]){
                if(senate.charAt(i) == 'R'){
                    if(DLen > 0){
                        DLen--;
                        used[i] = true;
                        RNum--;
                    }else{
                        RLen++;
                    }
                }else{
                    if(RLen > 0){
                        RLen--;
                        used[i] = true;
                        DNum--;
                    }else{
                        DLen++;
                    }
                }
            }
        }
    }

    return DNum > 0 ? "Dire" : "Radiant";
}
```

## 2020/12/12

### 题目

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度中等321收藏分享切换为英文接收动态反馈

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 O(*n*) 时间复杂度完成此题?

### 思路

采用DP，从头到尾递推即可。

使用两个变量，hLen表示升序序列长度，lLen表示降序序列长度，都初始化为1

如果当前的数据比前一个数据大，则更新hLen，hLen = max(lLen + 1 , hLen)，如果比前一个数据小，则更新lLen，lLen = max(hLen + 1, lLen)。

为什么可以用前一个数据代替摆动数列的尾部呢？因为如果这一次比较无法更新数据，则用当前数据顶替尾部数据，例如当前摆动数列的尾部为7（上升），升序长度为10，当前数据为9，更新降序长度后，因为升序的下一个只能找降序，所以用10顶替7没有问题。

### 代码

```java
public int wiggleMaxLength(int[] nums){
    int len = nums.length;
    if(len < 2){
        return len;
    }

    int hLen = 1;          // 存储升序的长度
    int lLen = 1;          // 存储降序的长度

    for(int i = 1; i < len; i++){
        if(nums[i] > nums[i-1]){
            hLen = Math.max(lLen+1,hLen);
        }else if(nums[i] < nums[i-1]){
            lLen = Math.max(hLen+1,lLen);
        }
    }

    return Math.max(hLen,lLen);
}
```

## 2020/12/13

### 题目

[217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

难度简单334收藏分享切换为英文接收动态反馈

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

 

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```

### 思路

暴力的就排序，然后遍历数组，比较前后两个数字是否相同。

优化一点就使用HashSet来存储数据，然后根据HashSet的size()和数组长度进行比较，如果一致，则无重复。这个还可以进一步剪枝，因为Set的add()方法根据添加成功与否会返回一个boolean值，如果出现一次添加失败，则可以判断有重复数据

### 代码

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> data = new HashSet<>();
    for(int i = 0; i < nums.length; i++){
        if(!data.add(nums[i])){
            return true;
        }
    }

    return false;
}
```

## 2020/12/14

### 题目

[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

难度中等601收藏分享切换为英文接收动态反馈

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

### 思路

解法一（我的解法）给每一个字符串一个Hash值，Hash值的有如下规则

- 不同长度的字符串Hash值一定不等
- 相同长度，组成字母一样的字符串Hash值相等

具体实现看代码，不过这是很取巧的方式，因为一旦字符串的长度很长，位数的设置值太大，使得int超出范围(不过采取long类型可以避免)，由于字符的值最大才25（字符 - 'a'），所以才能平方那么多次，不过代价就是运行慢，主要时间都花费在计算Hash值（也可以采取其他计算方法，例如映射成质数，然后把映射的值相乘取mod，由于Hash的计算方法简单，而且没有其他处理，所以肯定存在某个数Hash相同而构成不同）



解法二：

将每一个字符串转化成char[]，这样就可以对数组进行排序，排序完再转化成String，然后通过HashMap来存储，相同构成字符串在排序后是一样的，这种就比我的快多了

### 代码

解法一

```java
 public List<List<String>> groupAnagrams(String[] strs) {
     int len = strs.length;
     List<List<String>> ans = new LinkedList<>();
     if(len == 0){
         return ans;
     }

     Integer[] data = new Integer[len];
     Integer[] index = new Integer[len];
     for(int i = 0; i < len; i++){
         data[i] = getNum(strs[i]);
         index[i] = i;
     }

     Arrays.sort(index, new Comparator<Integer>() {
         @Override
         public int compare(Integer o1, Integer o2) {
             return data[o1] - data[o2];
         }
     });

     List<String> tempList = new LinkedList<>();
     tempList.add(strs[index[0]]);
     ans.add(tempList);

     for(int i = 1; i < len; i++){
         if(data[index[i]].equals(data[index[i-1]])){
             tempList.add(strs[index[i]]);
         }else{
             tempList = new LinkedList<>();
             tempList.add(strs[index[i]]);
             ans.add(tempList);
         }
     }
     return ans;
 }

public int getNum(String data){
    int len = data.length();
    int ans = 0;
    for(int i = 0; i < len; i++){
        ans += Math.pow((data.charAt(i) - 'a') + 1,5);
    }
    ans += (len * 100000000);
    return ans;
}
```

解法二

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<String, List<String>>();
    for (String str : strs) {
        char[] array = str.toCharArray();
        Arrays.sort(array);
        String key = new String(array);
        List<String> list = map.getOrDefault(key, new ArrayList<String>());
        list.add(str);
        map.put(key, list);
    }
    return new ArrayList<List<String>>(map.values());
}
```

## 2020/12/15

### 题目

[738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

难度中等88收藏分享切换为英文接收动态反馈

给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）

**示例 1:**

```
输入: N = 10
输出: 9
```

**示例 2:**

```
输入: N = 1234
输出: 1234
```

**示例 3:**

```
输入: N = 332
输出: 299
```

**说明:** `N` 是在 `[0, 10^9]` 范围内的一个整数。

### 思路

解法一：

转换成从头到尾找第一个出现不协调的地方，即前面比后面大，然后再往前找和这个数相同的位，更新不协调位，因为当前位-1后，如果上一个数和当前数相同，会出现新的不协调，把不协调位的值-1，然后把它后面的位都置9

解法二：

从尾到头取数据，如果当前位比前一位大，则当前位乘以权值-1（相当于当前位-1，后面所有位指9）替换目标值，否则就把当前位乘以权值加到目标值，重复这个过程，直到遍历完。

这个写的实在是太漂亮了，虽然我一开始也想了直接用Int来解决，但是觉得实现起来可能和解法一没什么区别，就是优化一点点，但是这个就写的太漂亮了。

### 代码

解法一：

```java
public int monotoneIncreasingDigits(int N) {
    if(N < 10){
        return N;
    }

    char[] data = String.valueOf(N).toCharArray();
    int len = data.length;
    // 找到第一个出现不协调的地方
    for(int i = 0; i < len - 1; i++){
        if (data[i] > data[i+1]){
            // 往前搜索和他相同的数字
            int temp = data[i];
            for(int j = i - 1; j >= 0; j--){
                if(temp == data[j]){
                    i--;
                }
            }
            data[i] = (char)(data[i] - 1);
            for(int j = i + 1; j < len; j++){
                data[j] = '9';
            }
            break;
        }
    }

    return Integer.valueOf(String.valueOf(data));
}
```

解法二：

```java
public int monotoneIncreasingDigits(int N) {
    int rs = 0, exp = 1, p = 10;
    while (N > 0) {
        int t = N % 10;
        if (t <= p) {
            rs += t * exp;
            p = t;
        }
        else {
            rs = t * exp - 1;
            p = t - 1;
        }
        N /= 10;
        exp *= 10;
    }
    return rs;
}
```

