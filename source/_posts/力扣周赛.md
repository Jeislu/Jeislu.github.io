---
title: 力扣周赛
top: 1
date: 2020-12-31 17:17:20
tags:
 - 算法
---

## 前言

2021开新坑，以后也开始打力扣的周赛，在没有意外的情况下，应该是每周一更。其实打周赛是想试试不知道如何纠错的方法，毕竟不是每一个问题都有错误例子给你的，这方面的能力也需要锻炼，加油！

<!-- more -->

## 2021/1/3

### 第一题（√）

[5641. 卡车上的最大单元数](https://leetcode-cn.com/problems/maximum-units-on-a-truck/)

请你将一些箱子装在 **一辆卡车** 上。给你一个二维数组 `boxTypes` ，其中 `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]` ：

- `numberOfBoxesi` 是类型 `i` 的箱子的数量。
- `numberOfUnitsPerBoxi` 是类型 `i` 每个箱子可以装载的单元数量。

整数 `truckSize` 表示卡车上可以装载 **箱子** 的 **最大数量** 。只要箱子数量不超过 `truckSize` ，你就可以选择任意箱子装到卡车上。

返回卡车可以装载 **单元** 的 **最大** 总数*。*

 

**示例 1：**

```
输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
输出：8
解释：箱子的情况如下：
- 1 个第一类的箱子，里面含 3 个单元。
- 2 个第二类的箱子，每个里面含 2 个单元。
- 3 个第三类的箱子，每个里面含 1 个单元。
可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
```

**示例 2：**

```
输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
输出：91
```

 

**提示：**

- `1 <= boxTypes.length <= 1000`
- `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`
- `1 <= truckSize <= 106`

### 思路

签到题，没什么好说的，按最值钱的排序，然后一个一个拿

### 代码

```java
public int maximumUnits(int[][] boxTypes, int truckSize) {
    int len = boxTypes.length;
    // 按单元数排序
    Arrays.sort(boxTypes,(o1,o2) -> o2[1] - o1[1]);
    int ans = 0;
    for(int i = 0; i < len && truckSize != 0; i++){
        // 在总箱子或者剩下的空间里面取最小的
        int temp = Math.min(truckSize,boxTypes[i][0]);
        ans += temp * boxTypes[i][1];
        truckSize -= temp;
    }
    return ans;
}
```

### 第二题（×）

[5642. 大餐计数](https://leetcode-cn.com/problems/count-good-meals/)

**大餐** 是指 **恰好包含两道不同餐品** 的一餐，其美味程度之和等于 2 的幂。

你可以搭配 **任意** 两道餐品做一顿大餐。

给你一个整数数组 `deliciousness` ，其中 `deliciousness[i]` 是第 `i` 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 **大餐** 的数量。结果需要对 `109 + 7` 取余。

注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。



**示例 1：**

```
输入：deliciousness = [1,3,5,7,9]
输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
```

**示例 2：**

```
输入：deliciousness = [1,1,1,3,3,3,7]
输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
```

 

**提示：**

- `1 <= deliciousness.length <= 105`
- `0 <= deliciousness[i] <= 220`

### 思路

做是知道怎么做，但是看这个数据量，超时是肯定会超时的，由于没想到好的解法，就没有下手写。

后面看别人的思路，其实不难，我好长一段时间没接触过这种题了，一时间想不出来解法。

使用一个哈希表存储数据，然后遍历数据，查看哈希表里面是否存储可以和此数据组成2的幕，哈希表是遍历完一个数据加一个数据，这样有几个好处

- 第一，避免(1,3)，(3,1)这样不同顺序的重复计算的问题
- 第二，相同的数据可以按一样的代码计算，例如三个1自身组合，当遇到第一个1时，里面没有1，则不能，第二个1的时候，里面有一个1，大餐数+1，第三个1的时候，里面有两个1，大餐数+2，刚好是3；
- 第三，减少时间消耗

### 代码

```java
public int countPairs(int[] deliciousness) {
    // 结果取模
    int mod = 1000000007;
    int answer = 0;
    int len = deliciousness.length;
    // 使用一个哈希表来维护数据
    Map<Integer, Integer> map = new HashMap<>(len);
    for (int num : deliciousness) {
        int powerOfTwo = 1;
        // 数值最大为2^20，相加最大为2^21
        for (int i = 0; i <= 21; i++) {
            // 小剪枝，相加的数不可能比自身小
            if (powerOfTwo >= num && map.containsKey(powerOfTwo - num)) {
                answer += map.get(powerOfTwo - num);
                answer %= mod;
            }
            powerOfTwo *= 2;
        }
        // 存放数据
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    return answer;
}
```

### 第三题（×）

[5643. 将数组分成三个子数组的方案数](https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/)

我们称一个分割整数数组的方案是 **好的** ，当它满足：

- 数组被分成三个 **非空** 连续子数组，从左至右分别命名为 `left` ， `mid` ， `right` 。
- `left` 中元素和小于等于 `mid` 中元素和，`mid` 中元素和小于等于 `right` 中元素和。

给你一个 **非负** 整数数组 `nums` ，请你返回 **好的** 分割 `nums` 方案数目。由于答案可能会很大，请你将结果对 `109 + 7` 取余后返回。

 

**示例 1：**

```
输入：nums = [1,1,1]
输出：1
解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。
```

**示例 2：**

```
输入：nums = [1,2,2,2,5,0]
输出：3
解释：nums 总共有 3 种好的分割方案：
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
```

**示例 3：**

```
输入：nums = [3,2,1]
输出：0
解释：没有好的分割方案。
```

 

**提示：**

- `3 <= nums.length <= 105`
- `0 <= nums[i] <= 104`

### 思路

和第二题一样，知道怎么做，看数据量会超时，但是觉得能剪枝一下过，事实证明还是不行，还是超时，里面应该有一个最坏情况的例子。能过的解法思路如下：

遍历所有的数据，固定第一个分割线，然后找出第二个分割线的两个边界情况。

第一个边界情况直接遍历即可，因为会离左边较近，第二个边界情况使用二分法查找，然后通过两个边界就可以直接计算出可划分次数

### 代码

```java
public int waysToSplit(int[] nums) {
    int len = nums.length;
    int[] sum = new int[len + 1];
    // 存储最终答案
    long ans = 0;
    // 计算前n个数的和
    for (int i = 1; i <= len; i++) {
        sum[i] = sum[i-1] + nums[i-1];
    }

    // 最小为2
    int minIndex = 2;

    //  寻找第二个分界线的两个边界情况
    //  即 mid 的最小值和最大值
    for(int i = 1; i <= len - 2; i++){
        // 如果第一部分 * 3大于总合，则无需再判
        if(sum[i] * 3 > sum[len]){
            break;
        }
        // 寻找最小值
        minIndex = Math.max(minIndex,i+1);
        while(minIndex < len && sum[minIndex] - sum[i] < sum[i]){
            minIndex++;
        }
        // 越界情况
        if(minIndex > len){
            break;
        }

        // 二分法寻找最大值
        int left = minIndex;
        int right = len - 1;
        while(right >= left){
            int mid = (left + right) / 2;
            if(sum[len] - sum[mid] < sum[mid] - sum[i]){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        ans += right - minIndex + 1;
    }

    return (int)(ans % 1000000007);
}
```

### 第四题（未看）

这题就不说了，毕竟看都没看

### 总结

不得不说，第一次周赛就直接把我打傻，就做了一道签到题，虽然两道题有思路，但是超时和做不出来没多大区别。

不过也好，姿态放低，一步一步踏踏实实学，下一次周赛加油！