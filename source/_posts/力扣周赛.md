---
title: 力扣周赛
top: 1
date: 2020-12-31 17:17:20
tags:
 - 算法
---

## 前言

2021开新坑，以后也开始打力扣的周赛，在没有意外的情况下，应该是每周一更。其实打周赛是想试试不知道如何纠错的方法，毕竟不是每一个问题都有错误例子给你的，这方面的能力也需要锻炼，加油！

<!-- more -->

## 2021/1/3

### 第一题（√）

[5641. 卡车上的最大单元数](https://leetcode-cn.com/problems/maximum-units-on-a-truck/)

请你将一些箱子装在 **一辆卡车** 上。给你一个二维数组 `boxTypes` ，其中 `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]` ：

- `numberOfBoxesi` 是类型 `i` 的箱子的数量。
- `numberOfUnitsPerBoxi` 是类型 `i` 每个箱子可以装载的单元数量。

整数 `truckSize` 表示卡车上可以装载 **箱子** 的 **最大数量** 。只要箱子数量不超过 `truckSize` ，你就可以选择任意箱子装到卡车上。

返回卡车可以装载 **单元** 的 **最大** 总数*。*

 

**示例 1：**

```
输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
输出：8
解释：箱子的情况如下：
- 1 个第一类的箱子，里面含 3 个单元。
- 2 个第二类的箱子，每个里面含 2 个单元。
- 3 个第三类的箱子，每个里面含 1 个单元。
可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
```

**示例 2：**

```
输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
输出：91
```

 

**提示：**

- `1 <= boxTypes.length <= 1000`
- `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`
- `1 <= truckSize <= 106`

#### 思路

签到题，没什么好说的，按最值钱的排序，然后一个一个拿

#### 代码

```java
public int maximumUnits(int[][] boxTypes, int truckSize) {
    int len = boxTypes.length;
    // 按单元数排序
    Arrays.sort(boxTypes,(o1,o2) -> o2[1] - o1[1]);
    int ans = 0;
    for(int i = 0; i < len && truckSize != 0; i++){
        // 在总箱子或者剩下的空间里面取最小的
        int temp = Math.min(truckSize,boxTypes[i][0]);
        ans += temp * boxTypes[i][1];
        truckSize -= temp;
    }
    return ans;
}
```

### 第二题（×）

[5642. 大餐计数](https://leetcode-cn.com/problems/count-good-meals/)

**大餐** 是指 **恰好包含两道不同餐品** 的一餐，其美味程度之和等于 2 的幂。

你可以搭配 **任意** 两道餐品做一顿大餐。

给你一个整数数组 `deliciousness` ，其中 `deliciousness[i]` 是第 `i` 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 **大餐** 的数量。结果需要对 `109 + 7` 取余。

注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。



**示例 1：**

```
输入：deliciousness = [1,3,5,7,9]
输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
```

**示例 2：**

```
输入：deliciousness = [1,1,1,3,3,3,7]
输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
```

 

**提示：**

- `1 <= deliciousness.length <= 105`
- `0 <= deliciousness[i] <= 220`

#### 思路

做是知道怎么做，但是看这个数据量，超时是肯定会超时的，由于没想到好的解法，就没有下手写。

后面看别人的思路，其实不难，我好长一段时间没接触过这种题了，一时间想不出来解法。

使用一个哈希表存储数据，然后遍历数据，查看哈希表里面是否存储可以和此数据组成2的幕，哈希表是遍历完一个数据加一个数据，这样有几个好处

- 第一，避免(1,3)，(3,1)这样不同顺序的重复计算的问题
- 第二，相同的数据可以按一样的代码计算，例如三个1自身组合，当遇到第一个1时，里面没有1，则不能，第二个1的时候，里面有一个1，大餐数+1，第三个1的时候，里面有两个1，大餐数+2，刚好是3；
- 第三，减少时间消耗

#### 代码

```java
public int countPairs(int[] deliciousness) {
    // 结果取模
    int mod = 1000000007;
    int answer = 0;
    int len = deliciousness.length;
    // 使用一个哈希表来维护数据
    Map<Integer, Integer> map = new HashMap<>(len);
    for (int num : deliciousness) {
        int powerOfTwo = 1;
        // 数值最大为2^20，相加最大为2^21
        for (int i = 0; i <= 21; i++) {
            // 小剪枝，相加的数不可能比自身小
            if (powerOfTwo >= num && map.containsKey(powerOfTwo - num)) {
                answer += map.get(powerOfTwo - num);
                answer %= mod;
            }
            powerOfTwo *= 2;
        }
        // 存放数据
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    return answer;
}
```

### 第三题（×）

[5643. 将数组分成三个子数组的方案数](https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/)

我们称一个分割整数数组的方案是 **好的** ，当它满足：

- 数组被分成三个 **非空** 连续子数组，从左至右分别命名为 `left` ， `mid` ， `right` 。
- `left` 中元素和小于等于 `mid` 中元素和，`mid` 中元素和小于等于 `right` 中元素和。

给你一个 **非负** 整数数组 `nums` ，请你返回 **好的** 分割 `nums` 方案数目。由于答案可能会很大，请你将结果对 `109 + 7` 取余后返回。

 

**示例 1：**

```
输入：nums = [1,1,1]
输出：1
解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。
```

**示例 2：**

```
输入：nums = [1,2,2,2,5,0]
输出：3
解释：nums 总共有 3 种好的分割方案：
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
```

**示例 3：**

```
输入：nums = [3,2,1]
输出：0
解释：没有好的分割方案。
```

 

**提示：**

- `3 <= nums.length <= 105`
- `0 <= nums[i] <= 104`

#### 思路

和第二题一样，知道怎么做，看数据量会超时，但是觉得能剪枝一下过，事实证明还是不行，还是超时，里面应该有一个最坏情况的例子。能过的解法思路如下：

遍历所有的数据，固定第一个分割线，然后找出第二个分割线的两个边界情况。

第一个边界情况直接遍历即可，因为会离左边较近，第二个边界情况使用二分法查找，然后通过两个边界就可以直接计算出可划分次数

#### 代码

```java
public int waysToSplit(int[] nums) {
    int len = nums.length;
    int[] sum = new int[len + 1];
    // 存储最终答案
    long ans = 0;
    // 计算前n个数的和
    for (int i = 1; i <= len; i++) {
        sum[i] = sum[i-1] + nums[i-1];
    }

    // 最小为2
    int minIndex = 2;

    //  寻找第二个分界线的两个边界情况
    //  即 mid 的最小值和最大值
    for(int i = 1; i <= len - 2; i++){
        // 如果第一部分 * 3大于总合，则无需再判
        if(sum[i] * 3 > sum[len]){
            break;
        }
        // 寻找最小值
        minIndex = Math.max(minIndex,i+1);
        while(minIndex < len && sum[minIndex] - sum[i] < sum[i]){
            minIndex++;
        }
        // 越界情况
        if(minIndex > len){
            break;
        }

        // 二分法寻找最大值
        int left = minIndex;
        int right = len - 1;
        while(right >= left){
            int mid = (left + right) / 2;
            if(sum[len] - sum[mid] < sum[mid] - sum[i]){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        ans += right - minIndex + 1;
    }

    return (int)(ans % 1000000007);
}
```

### 第四题（未看）

这题就不说了，毕竟看都没看

### 总结

不得不说，第一次周赛就直接把我打傻，就做了一道签到题，虽然两道题有思路，但是超时和做不出来没多大区别。

不过也好，姿态放低，一步一步踏踏实实学，下一次周赛加油！

## 2021/1/10

### 第一题（√）

[5649. 解码异或后的数组](https://leetcode-cn.com/problems/decode-xored-array/)

**未知** 整数数组 `arr` 由 `n` 个非负整数组成。

经编码后变为长度为 `n - 1` 的另一个整数数组 `encoded` ，其中 `encoded[i] = arr[i] XOR arr[i + 1]` 。例如，`arr = [1,0,2,1]` 经编码后得到 `encoded = [1,2,3]` 。

给你编码后的数组 `encoded` 和原数组 `arr` 的第一个元素 `first`（`arr[0]`）。

请解码返回原数组 `arr` 。可以证明答案存在并且是唯一的。

 

**示例 1：**

```
输入：encoded = [1,2,3], first = 1
输出：[1,0,2,1]
解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
```

**示例 2：**

```
输入：encoded = [6,2,7,3], first = 4
输出：[4,2,0,7,4]
```

 

**提示：**

- `2 <= n <= 104`
- `encoded.length == n - 1`
- `0 <= encoded[i] <= 105`
- `0 <= first <= 105`

#### 思路

签到题，没什么好说，再异或一次就恢复原来的数了

#### 代码

```java
public int[] decode(int[] encoded, int first) {
    int len = encoded.length + 1;
    int[] ans = new int[len];
    ans[0] = first;
    for(int i = 1; i < len; i++){
        ans[i] = ans[i-1] ^ encoded[i-1];
    }

    return ans;
}
```

### 第二题（√）

[5652. 交换链表中的节点](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/)

给你链表的头节点 `head` 和一个整数 `k` 。

**交换** 链表正数第 `k` 个节点和倒数第 `k` 个节点的值后，返回链表的头节点（链表 **从 1 开始索引**）。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/10/linked1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5
输出：[7,9,6,6,8,7,3,0,9,5]
```

**示例 3：**

```
输入：head = [1], k = 1
输出：[1]
```

**示例 4：**

```
输入：head = [1,2], k = 1
输出：[2,1]
```

**示例 5：**

```
输入：head = [1,2,3], k = 2
输出：[1,2,3]
```

 

**提示：**

- 链表中节点的数目是 `n`
- `1 <= k <= n <= 105`
- `0 <= Node.val <= 100`

#### 思路

两次遍历，第一次计算出链表长度，第二次找出两个结点位置，然后交换即可

#### 代码

```java
public ListNode swapNodes(ListNode head, int k) {
    int len = 0;
    ListNode tempNode = head;
    // 计算长度
    while(tempNode != null){
        len++;
        tempNode = tempNode.next;
    }

    int count = 1;
    tempNode = head;
    ListNode change1 = null;
    ListNode change2 = null;
    while(count <= len){
        if(count == k){
            change1 = tempNode;
        }

        if(count == len - k + 1){
            change2 = tempNode;
        }

        if(change1 != null && change2 != null){
            break;
        }
        count++;
        tempNode = tempNode.next;
    }
    int temp = change1.val;
    change1.val = change2.val;
    change2.val = temp;
    return head;
}
```

### 第三题（×）

[5650. 执行交换操作后的最小汉明距离](https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/)

给你两个整数数组 `source` 和 `target` ，长度都是 `n` 。还有一个数组 `allowedSwaps` ，其中每个 `allowedSwaps[i] = [ai, bi]` 表示你可以交换数组 `source` 中下标为 `ai` 和 `bi`（**下标从 0 开始**）的两个元素。注意，你可以按 **任意** 顺序 **多次** 交换一对特定下标指向的元素。

相同长度的两个数组 `source` 和 `target` 间的 **汉明距离** 是元素不同的下标数量。形式上，其值等于满足 `source[i] != target[i]` （**下标从 0 开始**）的下标 `i`（`0 <= i <= n-1`）的数量。

在对数组 `source` 执行 **任意** 数量的交换操作后，返回 `source` 和 `target` 间的 **最小汉明距离** 。

 

**示例 1：**

```
输入：source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
输出：1
解释：source 可以按下述方式转换：
- 交换下标 0 和 1 指向的元素：source = [2,1,3,4]
- 交换下标 2 和 3 指向的元素：source = [2,1,4,3]
source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。
```

**示例 2：**

```
输入：source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
输出：2
解释：不能对 source 执行交换操作。
source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。
```

**示例 3：**

```
输入：source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
输出：0
```

 

**提示：**

- `n == source.length == target.length`
- `1 <= n <= 105`
- `1 <= source[i], target[i] <= 105`
- `0 <= allowedSwaps.length <= 105`
- `allowedSwaps[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`

#### 思路

1和3可以交换，2和4可以交换，1和2可以交换，这就意味着3和4可以交换，因为交换没有顺序和次数限制。

根据这个思路，只要把所有的连通的归到一起，然后分别计算每个连通里面的不同数字的数量即可

但是，我不知道怎么写，硬要写应该可能可以吧，但是绝对不够简洁而且估计很费时间。

一开始默认可以交换的都在一个连通里面，提交后才想起不是。

### 第四题（×）

[5639. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)

难度困难17收藏分享切换为英文接收动态反馈

给你一个整数数组 `jobs` ，其中 `jobs[i]` 是完成第 `i` 项工作要花费的时间。

请你将这些工作分配给 `k` 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 **工作时间** 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 **最大工作时间** 得以 **最小化** 。

返回分配方案中尽可能 **最小** 的 **最大工作时间** 。

 

**示例 1：**

```
输入：jobs = [3,2,3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。
```

**示例 2：**

```
输入：jobs = [1,2,4,7,8], k = 2
输出：11
解释：按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。
```

 

**提示：**

- `1 <= k <= jobs.length <= 12`
- `1 <= jobs[i] <= 107`

#### 思路

题目朴实易懂，看到的一瞬间我就知道我解不出来，因为这道题我见过，我只会一个贪心的近似解，没去钻研 dp 状态压缩，没办法

### 总结

说实话，前两道太简单了，没什么实感，第三道思路想出来了，但是想不出好的代码解决，不是我不想硬写，估计硬写出来，别人午睡都醒了，第四题就不说了。

觉得还需要更加努力，虽然不是专门搞算法的，但是基础的算法不能落下，而且脑子不能生锈，保持状态。